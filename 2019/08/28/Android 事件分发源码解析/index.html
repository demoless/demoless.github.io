<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>Android 事件分发源码解析 | demoless.github.io</title><meta name="description" content="开发艺术读书笔记"><meta name="keywords" content="Android,源码分析"><meta name="author" content="zhf"><meta name="copyright" content="zhf"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://yoursite.com/2019/08/28/Android 事件分发源码解析/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="Android 事件分发源码解析"><meta name="twitter:description" content="开发艺术读书笔记"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png"><meta property="og:type" content="article"><meta property="og:title" content="Android 事件分发源码解析"><meta property="og:url" content="http://yoursite.com/2019/08/28/Android 事件分发源码解析/"><meta property="og:site_name" content="demoless.github.io"><meta property="og:description" content="开发艺术读书笔记"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="Gradle学习笔记" href="http://yoursite.com/2020/04/09/Gradle学习笔记/"><link rel="next" title="Android XML布局到View对象创建流程分析" href="http://yoursite.com/2019/08/18/Android View对象创建流程分析/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Bookmark',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days'

  
}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#事件体系简介"><span class="toc-number">1.</span> <span class="toc-text">事件体系简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MotionEvent"><span class="toc-number">1.1.</span> <span class="toc-text">MotionEvent</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#正文"><span class="toc-number">2.</span> <span class="toc-text">正文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Activity的事件分发"><span class="toc-number">3.</span> <span class="toc-text">Activity的事件分发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Window的事件分发"><span class="toc-number">4.</span> <span class="toc-text">Window的事件分发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ViewGroup的事件分发"><span class="toc-number">5.</span> <span class="toc-text">ViewGroup的事件分发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#public-boolean-dispatchTouchEvent-MotionEvent-ev"><span class="toc-number">5.1.</span> <span class="toc-text">public boolean dispatchTouchEvent(MotionEvent ev)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#public-boolean-onInterceptTouchEvent-MotionEvent-ev"><span class="toc-number">5.2.</span> <span class="toc-text">public boolean onInterceptTouchEvent(MotionEvent ev)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#public-boolean-onTouchEvent-MotionEvent-ev"><span class="toc-number">5.3.</span> <span class="toc-text">public boolean onTouchEvent(MotionEvent ev)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#View的事件分发"><span class="toc-number">6.</span> <span class="toc-text">View的事件分发</span></a></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/post.png)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">demoless.github.io</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"><div class="mobile_author-info__description"></div></div><hr><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Android 事件分发源码解析</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2019-08-28<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> Updated 2020-06-22</time><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">4.2k</span><span class="post-meta__separator">|</span><span>Reading time: 16 min</span><span class="post-meta__separator">|</span><span>Post View: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h2 id="事件体系简介"><a href="#事件体系简介" class="headerlink" title="事件体系简介"></a>事件体系简介</h2><p>既然是View的事件分发，那么首先我们应该知道什么是Android体系中的事件，它在code世界中又是如何定义的，下面我们简单介绍一些MotionEvent的知识。</p>
<h3 id="MotionEvent"><a href="#MotionEvent" class="headerlink" title="MotionEvent"></a>MotionEvent</h3><blockquote>
<p>Android体系中将所有的输入事件都放到了MotionEvent中，实际上MotionEvent已经发展到十分复杂，由于本文的重点不在这里，所以就单点触控事件进行介绍。</p>
</blockquote>
<p><strong>单点触控</strong></p>
<p>单点触控中有以下几个事件：</p>
<ul>
<li>ACTION_DOWN       手指初次接触到屏幕上时触发，简单地说就是手指按下触摸到屏幕的时候</li>
<li>ACTION_UP         手指离开屏幕时触发，及手指抬起离开屏幕时</li>
<li>ACTION_MOVE       手指在屏幕上滑动时触发，当手指在屏幕上连续一段距离后被识别为滑动，滑动在一次事件序列中可能会被触发多次，并不唯一</li>
<li>ACTION_CANCEL     当事件传递下来后又被上层收回时触发</li>
<li>ACTION_OUTSIDE    手指触控的区域不在控件上方时触发</li>
</ul>
<p>一次单点触控流程可以大概描述为手指按下（ACTION_DOWN）——&gt;手指在屏幕上滑动（ACTION_MOVE）——&gt;最后手指离开屏幕（ACTION_UP）,这是用户一般使用的简化过程。了解过这些基础事件后，我们再看几个MotionEvent常用API：</p>
<ul>
<li>getAction()   获取上述事件类型</li>
<li>getX()        获取触摸点相对于View的X轴坐标</li>
<li>getY()        获取触摸点相对于View的Y轴坐标</li>
<li>getRewX()     获取触摸点相对屏幕的X轴坐标</li>
<li>getRewY()     获取触摸点相对屏幕的Y轴坐标</li>
</ul>
<p>上面介绍的知识中首先要强调的是ACTION_MOVE在一次事件流程中可能触发的次数不唯一，其次就要介绍一下比较冷门的两个事件ACTION_CANCEL,ACTION_OUTSIDE。</p>
<ul>
<li>ACTION_CANCEL</li>
</ul>
<p>ACTION_CANCEL顾名思义取消事件，既然叫做取消那么就肯定存在先获取然后被收回这样一个过程，举个例子：你收到了一个会议消息，然后你又被告知这个会议被取消了；对应于View事件分发就是指事件序列分发到了某个环节，但他的上层又收回了这个事件序列，这时这个环节就会收到上层给他的ACTION_CANCEL事件.</p>
<ul>
<li>ACTION_OUTSIDE</li>
</ul>
<p>对于这个事件可能大家会觉得不可思议，明明触摸事件的发生点都不在该控件的所在区域，看起来不相关的两者是如何联系到一起的呢。实际上这种情况的确存在而且也具有它的意义。比如我们常用的Dialog，是不是会有这样的情况，我们点击它本身的关闭或取消按钮，而是点了一下它周围的其他区域，Dialog依然能够关闭；这种情况很多弹窗上出现的很多，就是这个ACTION_OUTSIDE事件的作用。</p>
<blockquote>
<p>对于Dialog是如何收到这个ACTION_OUTSIDE事件的，这主要是通过WindowManager的布局参数的flags设置为FLAG_WATCH_OUTSIDE_TOUCH，这样Daialog就具有了观察并处理超出本身范围的事件的能力</p>
</blockquote>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>Android事件分发从当前Activity开始，在到该Activity持有的Window，又由Window将事件传递给DecorView，最后又由DecorView再将事件分发给子View；如果子View并不消费该事件，那么该事件序列又会被交给该View的父容器，再到DecorView，再到Window，最后又回到了Activity。这意味着如果一直没有View消费该事件序列，那么事件会回到Activity并被处理掉。</p>
<blockquote>
<p>当不考虑事件序列中途被拦截并消费，只考虑事件分发到View的情况，比如一个Button或者一个TextView。若该View并没有消费该事件的话，那么最多就会出现上述流程</p>
</blockquote>
<h2 id="Activity的事件分发"><a href="#Activity的事件分发" class="headerlink" title="Activity的事件分发"></a>Activity的事件分发</h2><p><img src="https://upload-images.jianshu.io/upload_images/10968127-8e9460cb6da64a4a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>Activity的事件分发在其dispatchTouchEvent方法里进行了处理，我们看源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>（ev.getAction() == MotionEvent.ACTION.DOWN）&#123;</span><br><span class="line">        onUserInteraction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(getWindow().superDispatchTouchEvent(ev))&#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们可以看到Activity直接将事件交给了Window处理，如果Window的superDispatchTouchEvent方法返回false，那么Activity就会调用他的onTouchEvent方法，这个里如何具体实现我们后面再看。那么事件已经到了Window了。</p>
<h2 id="Window的事件分发"><a href="#Window的事件分发" class="headerlink" title="Window的事件分发"></a>Window的事件分发</h2><p>我们知道Window是抽象类，唯一实现类是PhoneWindow，又因为该superDispatchTouchEvent是抽象方法，那么我们只有去PhoneWindow里去看该方法的实现，看源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent ev)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDecor.dispatchTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比于Activity将事件传到Window来说，Window的做法则要更加简单粗暴，这里直接传递到了DecorView，而这个DecorView就是我们一般说的顶级View，我们在layout包里写的xml文件就是它的子View。一般来说这个DecorView都是一个ViewGroup，所以事件序列来到了ViewGroup，我们继续看。</p>
<h2 id="ViewGroup的事件分发"><a href="#ViewGroup的事件分发" class="headerlink" title="ViewGroup的事件分发"></a>ViewGroup的事件分发</h2><p>ViewGroup大家应该已经比熟悉了，一般来说ViewGroup的很多逻辑<br>处理都跟其自身和其子View息息相关，就像View的measure、draw和layout方法类似，这里也很相似，首先我们来看看几个比较重要的方法：</p>
<h3 id="public-boolean-dispatchTouchEvent-MotionEvent-ev"><a href="#public-boolean-dispatchTouchEvent-MotionEvent-ev" class="headerlink" title="public boolean dispatchTouchEvent(MotionEvent ev)"></a>public boolean dispatchTouchEvent(MotionEvent ev)</h3><p>用于事件的分发。当事件传递到了该View后，该方法一定会被调用，上面关于Activity等的事件分发时，大家应该都看到了这个方法。该方法的返回值由其自身的onTouchEvent()方法和子View的dispatchTouchEvent方法共同决定。</p>
<h3 id="public-boolean-onInterceptTouchEvent-MotionEvent-ev"><a href="#public-boolean-onInterceptTouchEvent-MotionEvent-ev" class="headerlink" title="public boolean onInterceptTouchEvent(MotionEvent ev)"></a>public boolean onInterceptTouchEvent(MotionEvent ev)</h3><p>此方法会在上述方法内部被调用(View为ViewGroup时)，具体的View不会调用该方法。此方法用于判断是否拦截某个事件，返回结果表示是否拦截当前事件。当同一个事件序列中的某个事件被拦截后，此方法不会被再次调用。</p>
<h3 id="public-boolean-onTouchEvent-MotionEvent-ev"><a href="#public-boolean-onTouchEvent-MotionEvent-ev" class="headerlink" title="public boolean onTouchEvent(MotionEvent ev)"></a>public boolean onTouchEvent(MotionEvent ev)</h3><p>用于处理点击事件，返回结果用于判断是否消费事件，如果不消费，那么此view不会再收到该事件序列的其他事件。</p>
<p>下面我们结合ViewGroup的源码来分析它的事件分发机制，首先看dispatchTouchEvent方法，源码内容很长，我们一段一段的分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Handle an initial down. 注释1</span></span><br><span class="line">           <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">               <span class="comment">// Throw away all previous state when starting a new touch gesture.</span></span><br><span class="line">               <span class="comment">// The framework may have dropped the up or cancel event for the previous gesture</span></span><br><span class="line">               <span class="comment">// due to an app switch, ANR, or some other state change.</span></span><br><span class="line">               cancelAndClearTouchTargets(ev);</span><br><span class="line">               resetTouchState();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Check for interception.注释2</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line">           <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                   || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                   intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                   ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   intercepted = <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">               <span class="comment">// so this view group continues to intercept touches.注释3</span></span><br><span class="line">               intercepted = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>

<p>这里定义了一个名为handled的布尔值，根据命名我们可以猜测为是否处理的，显然事件还没有被处理，这也跟我们说的viewGroup的dispatchEvent方法默认不拦截事件相应证，然后再看注释1处，如果当前事件是ACTION_DOWN（下文简称down事件）的话，会调用两个方法，又看命名，第一个方法应该是清除并取消触摸的目标，第二个方法应该是重置触摸状态，那么到底与我们的猜测是否一致呢，通过查看这两个方法的源码和注释，与我们的猜测完全一致：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cancels and clears all touch targets.</span></span><br><span class="line"><span class="comment">     * 取消并清除所有触摸目标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAndClearTouchTargets</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//mFirstTouchTarget 一个成员变量，初始为null，如果事件被子view处理完后</span></span><br><span class="line">    <span class="comment">//这个值将被赋值并指向子view,</span></span><br><span class="line">        <span class="keyword">if</span> (mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> syntheticEvent = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (event == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">                event = MotionEvent.obtain(now, now,</span><br><span class="line">                        MotionEvent.ACTION_CANCEL, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0</span>);</span><br><span class="line">                event.setSource(InputDevice.SOURCE_TOUCHSCREEN);</span><br><span class="line">                syntheticEvent = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遍历单链表</span></span><br><span class="line">            <span class="keyword">for</span> (TouchTarget target = mFirstTouchTarget; target != <span class="keyword">null</span>; target = target.next) &#123;</span><br><span class="line">                resetCancelNextUpFlag(target.child);</span><br><span class="line">                dispatchTransformedTouchEvent(event, <span class="keyword">true</span>, target.child, target.pointerIdBits);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//清除触摸目标 进行了单链表的删除操作</span></span><br><span class="line">            clearTouchTargets();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (syntheticEvent) &#123;</span><br><span class="line">                event.recycle();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>再看另一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Resets all touch state in preparation for a new cycle.</span></span><br><span class="line"><span class="comment">     * 重置所有状态以进入新周期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resetTouchState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        clearTouchTargets();</span><br><span class="line">        resetCancelNextUpFlag(<span class="keyword">this</span>);</span><br><span class="line">        mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;</span><br><span class="line">        mNestedScrollAxes = SCROLL_AXIS_NONE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>再次回,到dispatchTouchEvent方法上来，看注释2处又做了什么，这里有定义了一个布尔值，表示是否拦截事件，然后的判断内容是如果事件down或者mFirstTouchTarget不为空的话则执行onInterceptTouchEvent方法，是不是down事件很好判断，前面说到mFirstTouchTarget在子view处理了事件后会被赋值，而想要交给viewgroup处理时，显然它等于null。所以onInterceptTouchEvent方法只会执行一次在这里就可以看出，并且当down事件被拦截后，之后的整个事件序列都会交给他处理（注释3）。但是在调用onIntercepTouchEvent方法之前还有一个叫disallowIntercept的布尔值，用于判断是否禁止拦截，主要受FLAG_DISALLOW_INTERCEPT这个标志位的影响，因为这个标志位子view可以通过一定方法来改变，使viewgroup不拦截该事件并将它传递到子view上，这听起来似乎可以用来解决滑动冲突，但是这得要求这个事件不是down事件，上文已经分析过了，因为此时会进行一系列重置工作，包括标记位。如果down事件并没有拦截呢，那么这个时候就要将事件传递给子View了(这可能会有点长)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得所有子view的数量</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line"><span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</span><br><span class="line">    <span class="comment">// Find a child that can receive the event.</span></span><br><span class="line">    <span class="comment">// Scan children from front to back.</span></span><br><span class="line">    <span class="comment">//创建了一个用于向子view分发touch事件的list</span></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">    <span class="comment">//遍历子view</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//获取子view的脚标</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(</span><br><span class="line">                childrenCount, i, customOrder);</span><br><span class="line">        <span class="comment">//通过脚标拿到子view对象</span></span><br><span class="line">        <span class="keyword">final</span> View child = getAndVerifyPreorderedView(</span><br><span class="line">                preorderedList, children, childIndex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there is a view that has accessibility focus we want it</span></span><br><span class="line">        <span class="comment">// to get the event first and if not handled we will perform a</span></span><br><span class="line">        <span class="comment">// normal dispatch. We may do a double iteration but this is</span></span><br><span class="line">        <span class="comment">// safer given the timeframe.</span></span><br><span class="line">        <span class="keyword">if</span> (childWithAccessibilityFocus != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            childWithAccessibilityFocus = <span class="keyword">null</span>;</span><br><span class="line">            i = childrenCount - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果view在播放动画或者点击事件的坐标不在该view区域内 则遍历下一个 </span></span><br><span class="line">        <span class="comment">//否则交由它处理</span></span><br><span class="line">        <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">                || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从单链表中拿到这个值为child的TouchTarget对象</span></span><br><span class="line">        newTouchTarget = getTouchTarget(child);</span><br><span class="line">        <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Child is already receiving touch within its bounds.</span></span><br><span class="line">            <span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></span><br><span class="line">            newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        resetCancelNextUpFlag(child);</span><br><span class="line">        <span class="comment">//调用dispatchTransformedTouchEvent方法，用于判断子view是否拦截事件</span></span><br><span class="line">        <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">            <span class="comment">// Child wants to receive touch within its bounds.</span></span><br><span class="line">            <span class="comment">//记录时间</span></span><br><span class="line">            mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">            <span class="comment">//记录子view的脚标</span></span><br><span class="line">            <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// childIndex points into presorted list, find original index</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                        mLastTouchDownIndex = j;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mLastTouchDownIndex = childIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//记录事件的坐标</span></span><br><span class="line">            mLastTouchDownX = ev.getX();</span><br><span class="line">            mLastTouchDownY = ev.getY();</span><br><span class="line">            <span class="comment">//为新触摸目标赋值 将child添加进链表并返回值</span></span><br><span class="line">            newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">            <span class="comment">//已经分发给新的触摸目标设置为true</span></span><br><span class="line">            alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//跳出循环，因为处理事件的view已经有了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The accessibility focus didn't handle the event, so clear</span></span><br><span class="line">        <span class="comment">// the flag and do a normal dispatch to all children.</span></span><br><span class="line">        ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//清空存放view的list</span></span><br><span class="line">    <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) preorderedList.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这一大片代码主要完成了遍历子View，然后判断子view是否能够接受到事件，如果能则将事件分发给子view，如果子view拦截该事件，就记录下它然后设置为newToucthTarget。判断子view是否拦截是dispatchTransformedTouchEvent这个方法来完成的，我们看看是怎么实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></span><br><span class="line"><span class="function"><span class="params">            View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Canceling motions is a special case.  We don't need to perform any transformations</span></span><br><span class="line">        <span class="comment">// or filtering.  The important part is the action, not the contents.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</span><br><span class="line">        <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">            event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">                handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handled = child.dispatchTouchEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">            event.setAction(oldAction);</span><br><span class="line">            <span class="keyword">return</span> handled;</span><br><span class="line">        &#125;</span><br><span class="line">···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只截取了最主要的一段代码，可以看到如果子view不为空，就调用子view的dispatchTouchEvent方法，否则调用父类View的dispatchTouchEvent方法，最后返回结果。如果子view拦截了事件返回true，那么viewgroup就会记录下它，并为newTouchTarget赋值，然后跳出循环不再遍历，这一点参见上面代码中的注释。到这里还会出现另一种情况，那就是子View的dispatchTouchEvent都返回了false，整个遍历过程都没有找到view来处理事件怎么办呢，显然这时候只能viewgroup自己来处理事件了，看看它是如何处理的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dispatch to touch targets.</span></span><br><span class="line"><span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// No touch targets so treat this as an ordinary view.</span></span><br><span class="line">    handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">    TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里又调用了dispatchTransformedTouchEvent方法，需要注意的是传入的child参数为null，根据上面的分析，这里会将事件交给View来处理，这就是Viewgroup的处理逻辑，下面再看view的事件处理过程是怎样的。</p>
<h2 id="View的事件分发"><a href="#View的事件分发" class="headerlink" title="View的事件分发"></a>View的事件分发</h2><p>view相比ViewGroup没有onInterceptTouchEvent方法，一点有事件传递到它，那么它的onTouchEvent方法就一定会被调用。view的onTouchEvent方法默认会消费事件，除非它是不可点击的，clickable和longClickable同时为false，所有view的longClickable默认都为false，，clickable就各不相同了，比如Button的clickable默认为true，TextView默认为false；但是当我们为TextView设置点击事件监听的时候，它依然能够消费事件，这主要是因为setOnClickListener的时候，会将clickable设置为true。下面来看看view的dispatchTouchEvent方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class="line">                result = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//noinspection SimplifiableIfStatement</span></span><br><span class="line">            ListenerInfo li = mListenerInfo;</span><br><span class="line">            <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                    &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">                result = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">                result = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从上往下可以看出，如果OnTouchListener不为null，并且是可以点击的则执行它的onTouch方法，如果onTouch返回true，那么事件处理就结束了，就不会执行下面的onTouchEvent方法，显然onTouchListener优先级高于onTouchEvent。然后我们再看onTouchEvent：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> x = event.getX();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> y = event.getY();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> action = event.getAction();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class="line">                || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class="line">                || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;<span class="comment">//注释1</span></span><br><span class="line">            <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">                setPressed(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line">            <span class="comment">// A disabled view that is clickable still consumes the touch</span></span><br><span class="line">            <span class="comment">// events, it just doesn't respond to them.</span></span><br><span class="line">            <span class="keyword">return</span> clickable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注释2</span></span><br><span class="line">        <span class="keyword">if</span> (mTouchDelegate != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mTouchDelegate.onTouchEvent(event)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到注释1处，当view处于不可用状态下，依然能处理点击事件，就像源码注释写的那样，这些view并不会响应，但依然消费了触摸事件。注释2处是view的代理来处理点击事件，处理机制与OnTouchListener相似，就不分析了。现在来看看在onTouchEvent中对具体的事件是如何处理的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">                <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                    mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line">                    <span class="keyword">if</span> ((viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class="line">                        handleTooltipUp();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果根本就是不可点击 那么设置的相关callback都会被移除</span></span><br><span class="line">                    <span class="keyword">if</span> (!clickable) &#123;</span><br><span class="line">                        removeTapCallback();</span><br><span class="line">                        removeLongPressCallback();</span><br><span class="line">                        mInContextButtonPress = <span class="keyword">false</span>;</span><br><span class="line">                        mHasPerformedLongPress = <span class="keyword">false</span>;</span><br><span class="line">                        mIgnoreNextUpEvent = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span> || prepressed) &#123;</span><br><span class="line">                       ...</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</span><br><span class="line">                            <span class="comment">// This is a tap, so remove the longpress check</span></span><br><span class="line">                            removeLongPressCallback();</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// Only perform take click actions if we were in the pressed state</span></span><br><span class="line">                            <span class="keyword">if</span> (!focusTaken) &#123;</span><br><span class="line">                                <span class="comment">// Use a Runnable and post this rather than calling</span></span><br><span class="line">                                <span class="comment">// performClick directly. This lets other visual state</span></span><br><span class="line">                                <span class="comment">// of the view update before click actions start.</span></span><br><span class="line">                                <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    mPerformClick = <span class="keyword">new</span> PerformClick();</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (!post(mPerformClick)) &#123;</span><br><span class="line">                                    performClickInternal();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125;</span><br><span class="line">                    ...</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">    &#125;            </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出只要CLICKABLE和LONG_CLICKABLE有一个为true，即为可点击状态，那么它就会消费这个事件。点击事件的触发在action_up这个事件，这个事件里可以看出主要调用了performClickInternal方法，其实这个方法也主要是调用的performClick方法，如果view设置了onClickListener，那么就会调用它的onClick方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">performClickInternal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Must notify autofill manager before performing the click actions to avoid scenarios where</span></span><br><span class="line">        <span class="comment">// the app has a click listener that changes the state of views the autofill service might</span></span><br><span class="line">        <span class="comment">// be interested on.</span></span><br><span class="line">        notifyAutofillManagerOnClick();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> performClick();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// We still need to call this method to handle the cases where performClick() was called</span></span><br><span class="line">        <span class="comment">// externally, instead of through performClickInternal()</span></span><br><span class="line">        notifyAutofillManagerOnClick();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> result;</span><br><span class="line">        <span class="keyword">final</span> ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnClickListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            playSoundEffect(SoundEffectConstants.CLICK);</span><br><span class="line">            li.mOnClickListener.onClick(<span class="keyword">this</span>);</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</span><br><span class="line"></span><br><span class="line">        notifyEnterOrExitForAutoFillIfNeeded(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>一开始我们就说过，在设置clickListener的时候，clickable会被设置为true，所以当我们为View设置OnClickListener或OnClickListener的时候，只要事件传递到它这里来，那么就会执行我们设置的逻辑。到这里View的事件分发也就讲完了，对事件分发的清楚认识对于滑动冲突的处理和自定义view都有极大的帮助。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">zhf</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/08/28/Android 事件分发源码解析/">http://yoursite.com/2019/08/28/Android 事件分发源码解析/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android    </a><a class="post-meta__tags" href="/tags/源码分析/">源码分析    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-buttom"><i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2020/04/09/Gradle学习笔记/"><img class="prev_cover lozad" data-src="https://cdn.jsdelivr.net/gh/demoless/imgs/note下载.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>Gradle学习笔记</span></div></a></div><div class="next-post pull-right"><a href="/2019/08/18/Android View对象创建流程分析/"><img class="next_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>Android XML布局到View对象创建流程分析</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span>Recommend</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/07/30/浅谈Handler内部原理/" title="浅谈Handler内部原理"><img class="relatedPosts_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_title">浅谈Handler内部原理</div></a></div><div class="relatedPosts_item"><a href="/2019/08/08/浅谈Window视图绑定与工作原理/" title="浅谈Window视图绑定与工作原理"><img class="relatedPosts_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_title">浅谈Window视图绑定与工作原理</div></a></div><div class="relatedPosts_item"><a href="/2019/08/02/浅谈App启动流程/" title="浅谈App启动流程"><img class="relatedPosts_cover lozad" data-src="https://cdn.jsdelivr.net/gh/demoless/imgs/notestartActivity_jpg.jpg"><div class="relatedPosts_title">浅谈App启动流程</div></a></div><div class="relatedPosts_item"><a href="/2019/08/18/Android View对象创建流程分析/" title="Android XML布局到View对象创建流程分析"><img class="relatedPosts_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_title">Android XML布局到View对象创建流程分析</div></a></div><div class="relatedPosts_item"><a href="/2019/07/30/深入理解Handler/" title="深入理解Handler"><img class="relatedPosts_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_title">深入理解Handler</div></a></div><div class="relatedPosts_item"><a href="/2020/04/09/Gradle学习笔记/" title="Gradle学习笔记"><img class="relatedPosts_cover lozad" data-src="https://cdn.jsdelivr.net/gh/demoless/imgs/note下载.png"><div class="relatedPosts_title">Gradle学习笔记</div></a></div></div><div class="clear_both"></div></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2020 By zhf</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><i class="fa fa-book" id="readmode" title="Read Mode"> </i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion">简</a><i class="fa fa-moon-o nightshift" id="nightshift" title="Dark Mode"></i></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zindex="-1" data-click="false"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/js/piao.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script></body></html>