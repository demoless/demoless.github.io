<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>浅谈Window视图绑定与工作原理 | demoless.github.io</title><meta name="description" content="开发艺术读书笔记"><meta name="keywords" content="Android,源码分析"><meta name="author" content="zhf"><meta name="copyright" content="zhf"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://yoursite.com/2019/08/08/浅谈Window视图绑定与工作原理/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="浅谈Window视图绑定与工作原理"><meta name="twitter:description" content="开发艺术读书笔记"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png"><meta property="og:type" content="article"><meta property="og:title" content="浅谈Window视图绑定与工作原理"><meta property="og:url" content="http://yoursite.com/2019/08/08/浅谈Window视图绑定与工作原理/"><meta property="og:site_name" content="demoless.github.io"><meta property="og:description" content="开发艺术读书笔记"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="next" title="浅谈App启动流程" href="http://yoursite.com/2019/08/02/浅谈App启动流程/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Bookmark',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days'

  
}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Window的创建"><span class="toc-number">1.</span> <span class="toc-text">Window的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Window与Activity间的依附"><span class="toc-number">2.</span> <span class="toc-text">Window与Activity间的依附</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建并初始化DecorView"><span class="toc-number">2.1.</span> <span class="toc-text">创建并初始化DecorView</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#添加Window以显示视图"><span class="toc-number">2.2.</span> <span class="toc-text">添加Window以显示视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更新界面完成Window添加"><span class="toc-number">2.3.</span> <span class="toc-text">更新界面完成Window添加</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">3.</span> <span class="toc-text">小结</span></a></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/post.png)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">demoless.github.io</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"><div class="mobile_author-info__description"></div></div><hr><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title"><div class="posttitle">浅谈Window视图绑定与工作原理</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2019-08-08<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> Updated 2019-08-08</time><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">4.2k</span><span class="post-meta__separator">|</span><span>Reading time: 19 min</span><span class="post-meta__separator">|</span><span>Post View: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><p>在一个APP中，其实UI的处理也就是视图的工作并不是交由Activity来处理的，Activity并不负责视图控制，它只是控制生命周期和处理事件。真正控制视图的是Window。一个Activity包含着一个Window，Window才是真正代表一个窗口。Activity就像一个控制器，统筹视图的添加与显示，以及通过其他回调方法，来与Window、以及View进行交互。举个什么例子呢，这似乎就像CPU和显卡之间的关系，CPU的工作就好像是这里的Activity，而显卡就好像是Window，主要负责的是视图相关的工作绘制UI、加载图像之类的。那么什么是Window呢：</p>
<ul>
<li>Window是一个抽象的概念，它是所有View的直接管理者，任何视图都需要通过Window来呈现在界面上，当然除了单纯的界面视图的处理以外，视图的逻辑部分Window也会涉及处理，就像View的事件分发一样，中间还是需要经过一层的Window的处理</li>
</ul>
<h2 id="Window的创建"><a href="#Window的创建" class="headerlink" title="Window的创建"></a>Window的创建</h2><p>上次简单分析完了App启动流程，在流程最后的activity的创建部分，调用了activity.attach方法，我们只是简单的提了一下是关于Window的创建与绑定，现在我们就以这个方法为入口来看看Window与APP视图的工作原理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WindowManagerGlobal.initialize();</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Activity a = performLaunchActivity(r, customIntent);</span><br></pre></td></tr></table></figure>

<p>initialize函数主要是在WindowManagerGlobal中获取WindowManagerService的代理,然后performLaunchActivity会通过反射创建并返回一个Activity对象,先看initialize方法吧:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getWindowManagerService();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWindowManager <span class="title">getWindowManagerService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (WindowManagerGlobal.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sWindowManagerService == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//通过向ServiceManager查询一个字符串为window的key返回一个IBinder对象</span></span><br><span class="line">                <span class="comment">//然后asInterface方法又会返回一个本地代理</span></span><br><span class="line">                sWindowManagerService = IWindowManager.Stub.asInterface(</span><br><span class="line">                        ServiceManager.getService(<span class="string">"window"</span>));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sWindowManagerService != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//设置动画</span></span><br><span class="line">                        ValueAnimator.setDurationScale(</span><br><span class="line">                                sWindowManagerService.getCurrentAnimatorScale());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sWindowManagerService;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里是一个doubleCheck方式的单例，返回了一个WinowManagerService的代理，通过IWindowManager.Stub.asInterface方法获取到的，这很显然是AIDL的方式，这与App进程与系统进程通信时，获取ActivityManagerService代理是不是简直一模一样呢。然后再看performLaunchActivity方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里省略大部分代码</span></span><br><span class="line"> <span class="comment">// 调用activity的attach方法</span></span><br><span class="line">activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                r.referrer, r.voiceInteractor, window, r.configCallback);</span><br><span class="line">··· ···</span><br></pre></td></tr></table></figure>

<p>也就是说在Activity的创建过程中，也会把视图相关的对象绑定到当前Activity上，现在来看看具体是如何工作的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span></span><br><span class="line"><span class="function"><span class="params">        Instrumentation instr, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">        Application application, Intent intent, ActivityInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        CharSequence title, Activity parent, String id,</span></span></span><br><span class="line"><span class="function"><span class="params">        NonConfigurationInstances lastNonConfigurationInstances,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        Window window, ActivityConfigCallback activityConfigCallback)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注释1</span></span><br><span class="line">    attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">    mFragments.attachHost(<span class="keyword">null</span> <span class="comment">/*parent*/</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//注释2</span></span><br><span class="line">    mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window, activityConfigCallback);</span><br><span class="line">    mWindow.setWindowControllerCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.setCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.setOnWindowDismissedCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.getLayoutInflater().setPrivateFactory(<span class="keyword">this</span>);</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mWindow.setContainer(mParent.getWindow());</span><br><span class="line">    &#125;</span><br><span class="line">    mWindowManager = mWindow.getWindowManager();</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里还是只留下了与今天主题相关部分的代码，首先注释1处会为activity绑定上下文，注释2处创建了一个Window对象，之所以是一个PhoneWindow对象，是因为Window是一个抽象类，具体的实现类就是PhoneWindow，然后为Window对象设置各类监听器和一个WindowManager，activity实现了Window的Callback接口，所以当Window视图发生变化时会回调Activity的方法。到这里Window的创建就完成了，那么Window是怎么接管Activity的视图的，Window又是如何附属在Activity上的，下面开始分析。</p>
<h2 id="Window与Activity间的依附"><a href="#Window与Activity间的依附" class="headerlink" title="Window与Activity间的依附"></a>Window与Activity间的依附</h2><p>Activity的视图部分添加一般都会在onCreate方法里调用setContentView方法，那么我们只需要看setContentView方法即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(@LayoutRes <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">        getWindow().setContentView(layoutResID);</span><br><span class="line">        initWindowDecorActionBar();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Window <span class="title">getWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mWindow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从Activity的setContentView的实现可以看出，它将具体实现交给了Window，而这个mWindow就是之前的new PhoneWindow，所以这里真正实现的是PhoneWindow的setContentView方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span></span><br><span class="line">        <span class="comment">// decor, when theme attributes and the like are crystalized. Do not check the feature</span></span><br><span class="line">        <span class="comment">// before this happens.</span></span><br><span class="line">        <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            installDecor();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">            mContentParent.removeAllViews();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">            <span class="keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                    getContext());</span><br><span class="line">            transitionTo(newScene);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 将View添加到DecorView的mContentParent中</span></span><br><span class="line">         <span class="comment">// 调用LayoutInflater的inflate方法解析布局文件，并生成View树，mContentParent为View树的根节点</span></span><br><span class="line">            mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">        &#125;</span><br><span class="line">        mContentParent.requestApplyInsets();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//回调Activity的onContentChanged方法通知视图发生改变</span></span><br><span class="line">        <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">        <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">            cb.onContentChanged();</span><br><span class="line">        &#125;</span><br><span class="line">        mContentParentExplicitlySet = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>首先是调用installDecor方法在PhoneWindow内部创建一个DecorView：</p>
<h3 id="创建并初始化DecorView"><a href="#创建并初始化DecorView" class="headerlink" title="创建并初始化DecorView"></a>创建并初始化DecorView</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       mForceDecorInstall = <span class="keyword">false</span>;</span><br><span class="line">       <span class="comment">//通过generateDecor方法创建DecorView</span></span><br><span class="line">       <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">           mDecor = generateDecor(-<span class="number">1</span>);</span><br><span class="line">           mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class="line">           mDecor.setIsRootNamespace(<span class="keyword">true</span>);</span><br><span class="line">           <span class="keyword">if</span> (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != <span class="number">0</span>) &#123;</span><br><span class="line">               mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           mDecor.setWindow(<span class="keyword">this</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//通过generateLayout加载布局文件到DecorView，具体的布局与设置的主题和系统版本有关</span></span><br><span class="line">       <span class="comment">//最终返回一个ViewGroup对象并赋值给mContentParent</span></span><br><span class="line">       <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">           mContentParent = generateLayout(mDecor);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Set up decor part of UI to ignore fitsSystemWindows if appropriate.</span></span><br><span class="line">           mDecor.makeOptionalFitsSystemWindows();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">final</span> DecorContentParent decorContentParent = (DecorContentParent) mDecor.findViewById(</span><br><span class="line">                   R.id.decor_content_parent);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (decorContentParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">               mDecorContentParent = decorContentParent;</span><br><span class="line">               mDecorContentParent.setWindowCallback(getCallback());</span><br><span class="line">               <span class="keyword">if</span> (mDecorContentParent.getTitle() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   mDecorContentParent.setWindowTitle(mTitle);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               ···</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               mTitleView = findViewById(R.id.title);</span><br><span class="line">               <span class="keyword">if</span> (mTitleView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> ((getLocalFeatures() &amp; (<span class="number">1</span> &lt;&lt; FEATURE_NO_TITLE)) != <span class="number">0</span>) &#123;</span><br><span class="line">                       <span class="keyword">final</span> View titleContainer = findViewById(R.id.title_container);</span><br><span class="line">                       <span class="keyword">if</span> (titleContainer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           titleContainer.setVisibility(View.GONE);</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           mTitleView.setVisibility(View.GONE);</span><br><span class="line">                       &#125;</span><br><span class="line">                       mContentParent.setForeground(<span class="keyword">null</span>);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       mTitleView.setText(mTitle);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (mDecor.getBackground() == <span class="keyword">null</span> &amp;&amp; mBackgroundFallbackResource != <span class="number">0</span>) &#123;</span><br><span class="line">               mDecor.setBackgroundFallback(mBackgroundFallbackResource);</span><br><span class="line">           &#125;</span><br><span class="line">          ···</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>首先会通过generateDecor方法直接创建一个DecorView对象，然后在调用generateLayout赋值给mContentParent：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DecorView <span class="title">generateDecor</span><span class="params">(<span class="keyword">int</span> featureId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// System process doesn't have application context and in that case we need to directly use</span></span><br><span class="line">        <span class="comment">// the context we have. Otherwise we want the application context, so we don't cling to the</span></span><br><span class="line">        <span class="comment">// activity.</span></span><br><span class="line">        Context context;</span><br><span class="line">        <span class="keyword">if</span> (mUseDecorContext) &#123;</span><br><span class="line">            Context applicationContext = getContext().getApplicationContext();</span><br><span class="line">            <span class="keyword">if</span> (applicationContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">                context = getContext();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                context = <span class="keyword">new</span> DecorContext(applicationContext, getContext());</span><br><span class="line">                <span class="keyword">if</span> (mTheme != -<span class="number">1</span>) &#123;</span><br><span class="line">                    context.setTheme(mTheme);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            context = getContext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DecorView(context, featureId, <span class="keyword">this</span>, getAttributes());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">protected</span> ViewGroup <span class="title">generateLayout</span><span class="params">(DecorView decor)</span> </span>&#123;</span><br><span class="line">   ....</span><br><span class="line"></span><br><span class="line">   mDecor.startChanging();</span><br><span class="line">   mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);</span><br><span class="line"></span><br><span class="line">   ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class="line"></span><br><span class="line">   ....</span><br><span class="line"></span><br><span class="line">   mDecor.finishChanging();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> contentParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里findViewById(ID_ANDROID_CONTENT)通过这个Id找到是哪个View呢，其实就是mContentParent，这个ViewGroup是整个contentView中所有view的根节点。这里我么能通过查看系统布局文件，可以发现这个View是一个FrameLayout：</p>
<p><strong>screen_simple.xml</strong>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fitsSystemWindows</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ViewStub</span> <span class="attr">android:id</span>=<span class="string">"@+id/action_mode_bar_stub"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:inflatedId</span>=<span class="string">"@+id/action_mode_bar"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout</span>=<span class="string">"@layout/action_mode_bar"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:theme</span>=<span class="string">"?attr/actionBarTheme"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:id</span>=<span class="string">"@android:id/content"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:foregroundInsidePadding</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:foregroundGravity</span>=<span class="string">"fill_horizontal|top"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:foreground</span>=<span class="string">"?android:attr/windowContentOverlay"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其实除了这个文件以外的其他系统布局文件都会有这个id为content的FrameLayout，我们在Activity中设置的布局文件就会依附在这个FrameLayout上面，而整个布局属于decoerView，通常是一个LinearLayout。</p>
<blockquote>
<p>PhoneWindow的setContentView大概流程就是：首先创建DecorView和mContentParent，并将mContentParent添加到DecorView中，然后将解析出来的View以mContentParen为根节点添加到mContentParent中即添加到了DecorView中，最后回调Activity中的方法通知视图发生改变。</p>
</blockquote>
<p>这里我画了一张图来描述整个关系：</p>
<p><img src="http://assets.processon.com/chart_image/5d4bcd43e4b0423002be8ece.png" alt="DecorView内部结构"></p>
<h3 id="添加Window以显示视图"><a href="#添加Window以显示视图" class="headerlink" title="添加Window以显示视图"></a>添加Window以显示视图</h3><p>当View添加到了创建的DecorView上之后，这些View还没有真正显示到屏幕上，接下来就分析这个显示流程。那么在Activity的启动过程中，在哪一个环节实现的View的显示的呢，其实是在handleResumeActivity方法里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finalStateRequest, <span class="keyword">boolean</span> isForward,</span></span></span><br><span class="line"><span class="function"><span class="params">            String reason)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// If we are getting ready to gc after going to the background, well</span></span><br><span class="line">        <span class="comment">// we are back active so skip it.</span></span><br><span class="line">        unscheduleGcIdler();</span><br><span class="line">        mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO Push resumeArgs into the activity for consideration</span></span><br><span class="line">        <span class="comment">//调用了performResumeActivity方法执行生命周期中的onResume过程</span></span><br><span class="line">        <span class="comment">//通过token返回之前创建的ActivityClientRecord对象</span></span><br><span class="line">        <span class="keyword">final</span> ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class="line">        ···</span><br><span class="line">        <span class="keyword">final</span> Activity a = r.activity;</span><br><span class="line">        ···</span><br><span class="line">        <span class="keyword">boolean</span> willBeVisible = !a.mStartedActivity;</span><br><span class="line">        <span class="keyword">if</span> (!willBeVisible) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                willBeVisible = ActivityManager.getService().willActivityBeVisible(</span><br><span class="line">                        a.getActivityToken());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">            <span class="comment">//获取activity的window对象</span></span><br><span class="line">            r.window = r.activity.getWindow();</span><br><span class="line">            <span class="comment">//获取decorView</span></span><br><span class="line">            View decor = r.window.getDecorView();</span><br><span class="line">            <span class="comment">//decorView设置为不可见状态</span></span><br><span class="line">            decor.setVisibility(View.INVISIBLE);</span><br><span class="line">            <span class="comment">//获取WindowManager对象</span></span><br><span class="line">            ViewManager wm = a.getWindowManager();</span><br><span class="line">            WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">            a.mDecor = decor;</span><br><span class="line">            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">            l.softInputMode |= forwardBit;</span><br><span class="line">            <span class="keyword">if</span> (r.mPreserveWindow) &#123;</span><br><span class="line">                a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                r.mPreserveWindow = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// Normally the ViewRoot sets up callbacks with the Activity</span></span><br><span class="line">                <span class="comment">// in addView-&gt;ViewRootImpl#setView. If we are instead reusing</span></span><br><span class="line">                <span class="comment">// the decor view we have to notify the view root that the</span></span><br><span class="line">                <span class="comment">// callbacks may have changed.</span></span><br><span class="line">                ViewRootImpl impl = decor.getViewRootImpl();</span><br><span class="line">                <span class="keyword">if</span> (impl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    impl.notifyChildRebuilt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!a.mWindowAdded) &#123;</span><br><span class="line">                    a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">//WindowManager的adView方法添加decorView</span></span><br><span class="line">                    wm.addView(decor, l);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// The activity will get a callback for this &#123;@link LayoutParams&#125; change</span></span><br><span class="line">                    <span class="comment">// earlier. However, at that time the decor will not be set (this is set</span></span><br><span class="line">                    <span class="comment">// in this method), so no action will be taken. This call ensures the</span></span><br><span class="line">                    <span class="comment">// callback occurs with the decor set.</span></span><br><span class="line">                    <span class="comment">//如果decorview被设置过了的话，那么Window状态改变就调用回调方法</span></span><br><span class="line">                    a.onWindowAttributesChanged(l);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the window has already been added, but during resume</span></span><br><span class="line">            <span class="comment">// we started another activity, then don't yet make the</span></span><br><span class="line">            <span class="comment">// window visible.</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!willBeVisible) &#123;</span><br><span class="line">            <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Launch "</span> + r + <span class="string">" mStartedActivity set"</span>);</span><br><span class="line">            r.hideForNow = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            ···</span><br><span class="line">            WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">            <span class="keyword">if</span> ((l.softInputMode</span><br><span class="line">                    &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)</span><br><span class="line">                    != forwardBit) &#123;</span><br><span class="line">                l.softInputMode = (l.softInputMode</span><br><span class="line">                        &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION))</span><br><span class="line">                        | forwardBit;</span><br><span class="line">                <span class="keyword">if</span> (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">                    ViewManager wm = a.getWindowManager();</span><br><span class="line">                    View decor = r.window.getDecorView();</span><br><span class="line">                    wm.updateViewLayout(decor, l);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            r.activity.mVisibleFromServer = <span class="keyword">true</span>;</span><br><span class="line">            mNumVisibleActivities++;</span><br><span class="line">            <span class="keyword">if</span> (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">                r.activity.makeVisible();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这一步首先会执行handleResumeActivity方法完成生命周期的onResume方法，然后获取前面创建的ActivityClientRecord、PhoneWindow、DecorView、WindowManager等对象并调用WindowManager的addView方法;WindowMnager设个抽象类，实现类是WindowMnagerImpl,所以真正调用的是它的addView方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowManagerImpl</span> <span class="keyword">implements</span> <span class="title">WindowManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">        applyDefaultToken(params);</span><br><span class="line">        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现WindowManagerImpl并没有实现addView方法，而是交给了WindowManagerGlobal来处理;实际上除了addView添加View方法以外，更新视图的updataViewLayout和删除View的removeView方法也都交给了了WindowManagerGlobal来处理。WindowManagerImpl这种实现方式是典型的桥接模式，将所有的工作都委托给了WindowManagerGlobal来实现。现在看看WindowManagerGlobal的addView的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">        Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查参数是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"view must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (display == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"display must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(params <span class="keyword">instanceof</span> WindowManager.LayoutParams)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Params must be WindowManager.LayoutParams"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是子Window还需要调整参数</span></span><br><span class="line">    <span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</span><br><span class="line">    <span class="keyword">if</span> (parentWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">        parentWindow.adjustLayoutParamsForSubWindow(wparams);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If there's no parent, then hardware acceleration for this view is</span></span><br><span class="line">        <span class="comment">// set from the application's hardware acceleration setting.</span></span><br><span class="line">        <span class="keyword">final</span> Context context = view.getContext();</span><br><span class="line">        <span class="keyword">if</span> (context != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (context.getApplicationInfo().flags</span><br><span class="line">                        &amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>) &#123;</span><br><span class="line">            wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    View panelParentView = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ···</span><br><span class="line">        root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line"></span><br><span class="line">        view.setLayoutParams(wparams);</span><br><span class="line">        <span class="comment">//注释1</span></span><br><span class="line">        mViews.add(view);</span><br><span class="line">        mRoots.add(root);</span><br><span class="line">        mParams.add(wparams);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// do this last because it fires off messages to start doing things</span></span><br><span class="line">        <span class="comment">//调用ViewRootImpl来更新界面</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            root.setView(view, wparams, panelParentView);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="comment">// BadTokenException or InvalidDisplayException, clean up.</span></span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                removeViewLocked(index, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到注释1处，首先需要介绍几个WindowManagerGlobal中比较重要的成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;View&gt; mViews = <span class="keyword">new</span> ArrayList&lt;View&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;ViewRootImpl&gt; mRoots = <span class="keyword">new</span> ArrayList&lt;ViewRootImpl&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;WindowManager.LayoutParams&gt; mParams =</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;WindowManager.LayoutParams&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArraySet&lt;View&gt; mDyingViews = <span class="keyword">new</span> ArraySet&lt;View&gt;();</span><br></pre></td></tr></table></figure>

<p>上面的这几个变量中，mViews存储的是所有Window所对应的View，mRoots存储的是所有Window所对应的ViewRootImpl，mParams存储的是所有Window所对应的布局参数，而mDyingViews存储的是那些正在被删除的View对象，也就是被调用removeView方法还没执行完成。注释1处就会将Window中的一些对象存储到上述容器中。然后更新界面完成Window的添加，调用了ViewRootImpl的setView方法。</p>
<h3 id="更新界面完成Window添加"><a href="#更新界面完成Window添加" class="headerlink" title="更新界面完成Window添加"></a>更新界面完成Window添加</h3><p>了解过View的绘制的应该知道，该操作也是由ViewRootImpl来完成的，这里也不例外。通过调用setView方法然后内部调用requestLayout方法来完成异步刷新请求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mView == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mView = view;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//省略部分代码</span></span><br><span class="line">                mAdded = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">int</span> res; <span class="comment">/* = WindowManagerImpl.ADD_OKAY; */</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Schedule the first layout -before- adding to the window</span></span><br><span class="line">                <span class="comment">// manager, to make sure we do the relayout before receiving</span></span><br><span class="line">                <span class="comment">// any other events from the system.</span></span><br><span class="line">                <span class="comment">//异步刷新请求 开始View的绘制流程</span></span><br><span class="line">                requestLayout();</span><br><span class="line">                <span class="keyword">if</span> ((mWindowAttributes.inputFeatures</span><br><span class="line">                        &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>) &#123;</span><br><span class="line">                    mInputChannel = <span class="keyword">new</span> InputChannel();</span><br><span class="line">                &#125;</span><br><span class="line">                mForceDecorViewVisibility = (mWindowAttributes.privateFlags</span><br><span class="line">                        &amp; PRIVATE_FLAG_FORCE_DECOR_VIEW_VISIBILITY) != <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mOrigWindowType = mWindowAttributes.type;</span><br><span class="line">                    mAttachInfo.mRecomputeGlobalAttributes = <span class="keyword">true</span>;</span><br><span class="line">                    collectViewAttributes();</span><br><span class="line">                    <span class="comment">//注释1</span></span><br><span class="line">                    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                            getHostVisibility(), mDisplay.getDisplayId(), mWinFrame,</span><br><span class="line">                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                            mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    mAdded = <span class="keyword">false</span>;</span><br><span class="line">                    mView = <span class="keyword">null</span>;</span><br><span class="line">                    mAttachInfo.mRootView = <span class="keyword">null</span>;</span><br><span class="line">                    mInputChannel = <span class="keyword">null</span>;</span><br><span class="line">                    mFallbackEventHandler.setView(<span class="keyword">null</span>);</span><br><span class="line">                    unscheduleTraversals();</span><br><span class="line">                    setAccessibilityFocus(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Adding window failed"</span>, e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (restore) &#123;</span><br><span class="line">                        attrs.restore();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mTranslator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mTranslator.translateRectInScreenToAppWindow(mAttachInfo.mContentInsets);</span><br><span class="line">                &#125;</span><br><span class="line">                mPendingOverscanInsets.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                mPendingContentInsets.set(mAttachInfo.mContentInsets);</span><br><span class="line">                mPendingStableInsets.set(mAttachInfo.mStableInsets);</span><br><span class="line">                mPendingDisplayCutout.set(mAttachInfo.mDisplayCutout);</span><br><span class="line">                mPendingVisibleInsets.set(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                mAttachInfo.mAlwaysConsumeNavBar =</span><br><span class="line">                        (res &amp; WindowManagerGlobal.ADD_FLAG_ALWAYS_CONSUME_NAV_BAR) != <span class="number">0</span>;</span><br><span class="line">                mPendingAlwaysConsumeNavBar = mAttachInfo.mAlwaysConsumeNavBar;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_LAYOUT) Log.v(mTag, <span class="string">"Added window "</span> + mWindow);</span><br><span class="line">                <span class="keyword">if</span> (res &lt; WindowManagerGlobal.ADD_OKAY) &#123;</span><br><span class="line">                    mAttachInfo.mRootView = <span class="keyword">null</span>;</span><br><span class="line">                    mAdded = <span class="keyword">false</span>;</span><br><span class="line">                    mFallbackEventHandler.setView(<span class="keyword">null</span>);</span><br><span class="line">                    unscheduleTraversals();</span><br><span class="line">                    setAccessibilityFocus(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                 ···</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (view <span class="keyword">instanceof</span> RootViewSurfaceTaker) &#123;</span><br><span class="line">                    mInputQueueCallback =</span><br><span class="line">                        ((RootViewSurfaceTaker)view).willYouTakeTheInputQueue();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (mInputChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mInputQueueCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mInputQueue = <span class="keyword">new</span> InputQueue();</span><br><span class="line">                        mInputQueueCallback.onInputQueueCreated(mInputQueue);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mInputEventReceiver = <span class="keyword">new</span> WindowInputEventReceiver(mInputChannel,</span><br><span class="line">                            Looper.myLooper());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                view.assignParent(<span class="keyword">this</span>);</span><br><span class="line">                mAddedTouchMode = (res &amp; WindowManagerGlobal.ADD_FLAG_IN_TOUCH_MODE) != <span class="number">0</span>;</span><br><span class="line">                mAppVisible = (res &amp; WindowManagerGlobal.ADD_FLAG_APP_VISIBLE) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mAccessibilityManager.isEnabled()) &#123;</span><br><span class="line">                    mAccessibilityInteractionConnectionManager.ensureConnection();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (view.getImportantForAccessibility() == View.IMPORTANT_FOR_ACCESSIBILITY_AUTO) &#123;</span><br><span class="line">                    view.setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Set up the input pipeline.</span></span><br><span class="line">                CharSequence counterSuffix = attrs.getTitle();</span><br><span class="line">                mSyntheticInputStage = <span class="keyword">new</span> SyntheticInputStage();</span><br><span class="line">                InputStage viewPostImeStage = <span class="keyword">new</span> ViewPostImeInputStage(mSyntheticInputStage);</span><br><span class="line">                InputStage nativePostImeStage = <span class="keyword">new</span> NativePostImeInputStage(viewPostImeStage,</span><br><span class="line">                        <span class="string">"aq:native-post-ime:"</span> + counterSuffix);</span><br><span class="line">                InputStage earlyPostImeStage = <span class="keyword">new</span> EarlyPostImeInputStage(nativePostImeStage);</span><br><span class="line">                InputStage imeStage = <span class="keyword">new</span> ImeInputStage(earlyPostImeStage,</span><br><span class="line">                        <span class="string">"aq:ime:"</span> + counterSuffix);</span><br><span class="line">                InputStage viewPreImeStage = <span class="keyword">new</span> ViewPreImeInputStage(imeStage);</span><br><span class="line">                InputStage nativePreImeStage = <span class="keyword">new</span> NativePreImeInputStage(viewPreImeStage,</span><br><span class="line">                        <span class="string">"aq:native-pre-ime:"</span> + counterSuffix);</span><br><span class="line"></span><br><span class="line">                mFirstInputStage = nativePreImeStage;</span><br><span class="line">                mFirstPostImeInputStage = earlyPostImeStage;</span><br><span class="line">                mPendingInputEventQueueLengthCounterName = <span class="string">"aq:pending:"</span> + counterSuffix;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>setView内部通过requestLayout方法实现异步刷新请求，该方法内部会开始View的绘制流程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">            checkThread();</span><br><span class="line">            mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//View绘制流程的入口</span></span><br><span class="line">            scheduleTraversals();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里首先检查是否是创建View的线程，因为只有创建这些View的线程才可以操作这些View，然后调用了scheduleTraversals方法开始View的绘制流程，这里就不往里看了；但由于其内部实现方式View的绘制流程实际上在WindowSession的addToDisplay之后执行，这部分之后再细谈。接着看注释1处，通过调用mWindowSession的addToDisplay方法来完成最终的Window的添加过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/wm/Session.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addToDisplay</span><span class="params">(IWindow window, <span class="keyword">int</span> seq, WindowManager.LayoutParams attrs,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId, Rect outContentInsets, Rect outStableInsets,</span></span></span><br><span class="line"><span class="function"><span class="params">    Rect outOutsets, InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mService.addWindow(<span class="keyword">this</span>, window, seq, attrs, viewVisibility, displayId,</span><br><span class="line">        outContentInsets, outStableInsets, outOutsets, outInputChannel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mWindowSession是一个IWindowSession对象，也就是一个Binder，它是在ViewRootImpl构造方法中被创建的，也就是之前WindowManagerGlobal创建ViewRootImpl的时候。每个应用进程中只会有一个mWindowSession对象，WMS为每一个应用进程分配一个Session对象，应用进程通过这个对象与WindowManagerService通信。所以这里调用了WindowManagerService的addWindow方法<br>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span></span></span><br><span class="line"><span class="function"><span class="params">        LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId, Rect outFrame,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outContentInsets, Rect outStableInsets, Rect outOutsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] appOp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> res = mPolicy.checkAddPermission(attrs, appOp);</span><br><span class="line">    <span class="keyword">if</span> (res != WindowManagerGlobal.ADD_OKAY) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> reportNewConfig = <span class="keyword">false</span>;</span><br><span class="line">    WindowState parentWindow = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">long</span> origId;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> type = attrs.type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mDisplayReady) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Display has not been initialialized"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取DisplayContent</span></span><br><span class="line">        <span class="keyword">final</span> DisplayContent displayContent = getDisplayContentOrCreate(displayId);</span><br><span class="line"></span><br><span class="line">        ....</span><br><span class="line"></span><br><span class="line">        AppWindowToken atoken = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> hasParent = parentWindow != <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 调用displayContent的getWindowToken函数创建WindowToken</span></span><br><span class="line">        <span class="comment">// WindowToken保存在displayContent的mTokenMap哈希表中</span></span><br><span class="line">        <span class="comment">// Use existing parent window token for child windows since they go in the same token</span></span><br><span class="line">        <span class="comment">// as there parent window so we can apply the same policy on them.</span></span><br><span class="line">        WindowToken token = displayContent.getWindowToken(</span><br><span class="line">                hasParent ? parentWindow.mAttrs.token : attrs.token);</span><br><span class="line">        <span class="comment">// If this is a child window, we want to apply the same type checking rules as the</span></span><br><span class="line">        <span class="comment">// parent window type.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> rootType = hasParent ? parentWindow.mAttrs.type : type;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> addToastWindowRequiresToken = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (token == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ....</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> IBinder binder = attrs.token != <span class="keyword">null</span> ? attrs.token : client.asBinder();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> isRoundedCornerOverlay =</span><br><span class="line">                    (attrs.privateFlags &amp; PRIVATE_FLAG_IS_ROUNDED_CORNERS_OVERLAY) != <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 如果未能从displayContent获取到WindowToken则新建一个WindowToken</span></span><br><span class="line">            token = <span class="keyword">new</span> WindowToken(<span class="keyword">this</span>, binder, type, <span class="keyword">false</span>, displayContent,</span><br><span class="line">                    session.mCanAddInternalSystemWindow, isRoundedCornerOverlay);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rootType &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; rootType &lt;= LAST_APPLICATION_WINDOW) &#123;</span><br><span class="line">            <span class="comment">// 如果Window的类型为APPLICATION_WINDOW则将WindowToken转为AppWindowToken</span></span><br><span class="line">            atoken = token.asAppWindowToken();</span><br><span class="line">            <span class="keyword">if</span> (atoken == <span class="keyword">null</span>) &#123;</span><br><span class="line">               ...</span><br><span class="line">            &#125;</span><br><span class="line">         ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建WindowState保存Window</span></span><br><span class="line">        <span class="keyword">final</span> WindowState win = <span class="keyword">new</span> WindowState(<span class="keyword">this</span>, session, client, token, parentWindow,</span><br><span class="line">                appOp[<span class="number">0</span>], seq, attrs, viewVisibility, session.mUid,</span><br><span class="line">                session.mCanAddInternalSystemWindow);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为Window注册InputChannel</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> openInputChannels = (outInputChannel != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (attrs.inputFeatures &amp; INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>  (openInputChannels) &#123;</span><br><span class="line">            win.openInputChannel(outInputChannel);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用WindowState的attach函数</span></span><br><span class="line">        win.attach();</span><br><span class="line">        mWindowMap.put(client.asBinder(), win);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将新建的WindowState添加到WindowContainer的管理中，WindowContainer是WindowToken的父类</span></span><br><span class="line">        win.mToken.addWindow(win);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面函数主要的工作就是创建了一个WindowState对象，并调用了它的attach函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/wm/WindowState.java	</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Attaching "</span> + <span class="keyword">this</span> + <span class="string">" token="</span> + mToken);</span><br><span class="line">    mSession.windowAddedLocked(mAttrs.packageName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了Session的windowAddedLocked方法，内部创建了一个SurfaceSession对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/wm/Session.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">windowAddedLocked</span><span class="params">(String packageName)</span> </span>&#123;</span><br><span class="line">    mPackageName = packageName;</span><br><span class="line">    mRelayoutTag = <span class="string">"relayoutWindow: "</span> + mPackageName;</span><br><span class="line">    <span class="keyword">if</span> (mSurfaceSession == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (WindowManagerService.localLOGV) Slog.v(</span><br><span class="line">            TAG_WM, <span class="string">"First window added to "</span> + <span class="keyword">this</span> + <span class="string">", creating SurfaceSession"</span>);</span><br><span class="line">        mSurfaceSession = <span class="keyword">new</span> SurfaceSession();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (SHOW_TRANSACTIONS) Slog.i(</span><br><span class="line">                TAG_WM, <span class="string">"  NEW SURFACE SESSION "</span> + mSurfaceSession);</span><br><span class="line">        mService.mSessions.add(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (mLastReportedAnimatorScale != mService.getCurrentAnimatorScale()) &#123;</span><br><span class="line">            mService.dispatchNewAnimatorScaleLocked(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mNumWindow++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SurfaceSession对象承担了应用程序与SurfaceFlinger之间的通信过程，每一个需要与SurfaceFlinger进程交互的应用程序端都需要创建一个SurfaceSession对象。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到这里addToDisplay方法就分析完了，Window的添加请求是交给了WindowManagerService来处理的，具体的添加细节与实现原理就不再深入探索了，本文主要了解Window在启动过程的添加流程。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">zhf</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/08/08/浅谈Window视图绑定与工作原理/">http://yoursite.com/2019/08/08/浅谈Window视图绑定与工作原理/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android    </a><a class="post-meta__tags" href="/tags/源码分析/">源码分析    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-buttom"><i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2019/08/02/浅谈App启动流程/"><img class="next_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>浅谈App启动流程</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span>Recommend</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/07/30/浅谈Handler内部原理/" title="浅谈Handler内部原理"><img class="relatedPosts_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_title">浅谈Handler内部原理</div></a></div><div class="relatedPosts_item"><a href="/2019/08/02/浅谈App启动流程/" title="浅谈App启动流程"><img class="relatedPosts_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_title">浅谈App启动流程</div></a></div></div><div class="clear_both"></div></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2019 By zhf</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><i class="fa fa-book" id="readmode" title="Read Mode"> </i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion">简</a><i class="fa fa-moon-o nightshift" id="nightshift" title="Dark Mode"></i></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zindex="-1" data-click="false"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/js/piao.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script></body></html>