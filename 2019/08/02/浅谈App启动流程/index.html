<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>浅谈App启动流程 | demoless.github.io</title><meta name="description" content="开发艺术读书笔记"><meta name="keywords" content="Android,源码分析"><meta name="author" content="zhf"><meta name="copyright" content="zhf"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://yoursite.com/2019/08/02/浅谈App启动流程/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="浅谈App启动流程"><meta name="twitter:description" content="开发艺术读书笔记"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png"><meta property="og:type" content="article"><meta property="og:title" content="浅谈App启动流程"><meta property="og:url" content="http://yoursite.com/2019/08/02/浅谈App启动流程/"><meta property="og:site_name" content="demoless.github.io"><meta property="og:description" content="开发艺术读书笔记"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="浅谈Window视图绑定与工作原理" href="http://yoursite.com/2019/08/08/浅谈Window视图绑定与工作原理/"><link rel="next" title="Hello World" href="http://yoursite.com/2019/07/30/hello-world/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Bookmark',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days'

  
}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#从桌面图标的点击-Luancher——AMS"><span class="toc-number">1.</span> <span class="toc-text">从桌面图标的点击 Luancher——AMS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AMS——zygote过程"><span class="toc-number">2.</span> <span class="toc-text">AMS——zygote过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ActivityThread-main——App-onCreate"><span class="toc-number">3.</span> <span class="toc-text">ActivityThread#main——App#onCreate</span></a></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/post.png)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">demoless.github.io</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"><div class="mobile_author-info__description"></div></div><hr><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title"><div class="posttitle">浅谈App启动流程</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2019-08-02<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> Updated 2019-08-03</time><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">12.3k</span><span class="post-meta__separator">|</span><span>Reading time: 63 min</span><span class="post-meta__separator">|</span><span>Post View: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><p>本篇文章是基于android-9.0.0_r8分支的代码进行分析的，想要看framwork层源码的笔者推荐以下两种方式：</p>
<ul>
<li>github：<a href="https://github.com/aosp-mirror/platform_frameworks_base" target="_blank" rel="noopener">https://github.com/aosp-mirror/platform_frameworks_base</a></li>
<li>Android社区：<a href="https://www.androidos.net.cn/sourcecode" target="_blank" rel="noopener">https://www.androidos.net.cn/sourcecode</a></li>
</ul>
<p>当然可能还存在一些代码无法查看到，比如AIDL文件编译时自动生成的类，但那一般并不影响对整个流程的分析，看系统源码源码不应该深入代码细节不了自拔，把握流程及设计思想更重要，避免只见树木不见森林的情况（当然对大佬除外），笔者的实力也不支持对细节深入了解。</p>
<h2 id="从桌面图标的点击-Luancher——AMS"><a href="#从桌面图标的点击-Luancher——AMS" class="headerlink" title="从桌面图标的点击 Luancher——AMS"></a>从桌面图标的点击 Luancher——AMS</h2><p>当我们点击桌面图标到app开始启动，这个过程是从Luancher类开始的，Luancher继承于activity，他也实现了onClick方法，我们很容易想到在这个onClick方法里就有桌面图标点击事件的监听，即启动的入口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Object tag = v.getTag();</span><br><span class="line">    <span class="keyword">if</span> (tag <span class="keyword">instanceof</span> ShortcutInfo) &#123;</span><br><span class="line">        <span class="comment">// 从快捷方式图标启动</span></span><br><span class="line">        onClickAppShortcut(v);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag <span class="keyword">instanceof</span> FolderInfo) &#123;</span><br><span class="line">        <span class="comment">// 文件夹</span></span><br><span class="line">        <span class="keyword">if</span> (v <span class="keyword">instanceof</span> FolderIcon) &#123;</span><br><span class="line">           onClickFolderIcon(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v == mAllAppsButton) &#123;</span><br><span class="line">        <span class="comment">// “所有应用”按钮</span></span><br><span class="line">        onClickAllAppsButton(v);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag <span class="keyword">instanceof</span> AppInfo) &#123;</span><br><span class="line">        <span class="comment">// 从“所有应用”中启动的应用</span></span><br><span class="line">        startAppShortcutOrInfoActivity(v);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag <span class="keyword">instanceof</span> LauncherAppWidgetInfo) &#123;</span><br><span class="line">        <span class="comment">// 组件</span></span><br><span class="line">        <span class="keyword">if</span> (v <span class="keyword">instanceof</span> PendingAppWidgetHostView) &#123;</span><br><span class="line">            onClickPendingWidget((PendingAppWidgetHostView) v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看从快捷方式启动的onClickAppShortcut方法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Event handler for an app shortcut click.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v The view that was clicked. Must be a tagged with a &#123;<span class="doctag">@link</span> ShortcutInfo&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onClickAppShortcut</span><span class="params">(<span class="keyword">final</span> View v)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">        Object tag = v.getTag();</span><br><span class="line">        <span class="keyword">if</span> (!(tag <span class="keyword">instanceof</span> ShortcutInfo)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Input must be a Shortcut"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open shortcut</span></span><br><span class="line">        <span class="keyword">final</span> ShortcutInfo shortcut = (ShortcutInfo) tag;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shortcut.isDisabled != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((shortcut.isDisabled &amp;</span><br><span class="line">                    ~ShortcutInfo.FLAG_DISABLED_SUSPENDED &amp;</span><br><span class="line">                    ~ShortcutInfo.FLAG_DISABLED_QUIET_USER) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果应用程序仅因上述标志而被禁用，则无论如</span></span><br><span class="line">                <span class="comment">//何都会启动活动。框架将告诉用户应用程序暂停的原因。</span></span><br><span class="line">               </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ···</span><br><span class="line">        <span class="comment">// Check for abandoned promise</span></span><br><span class="line">        <span class="keyword">if</span> ((v <span class="keyword">instanceof</span> BubbleTextView) &amp;&amp; shortcut.isPromise()) &#123;</span><br><span class="line">            String packageName = shortcut.intent.getComponent() != <span class="keyword">null</span> ?</span><br><span class="line">                    shortcut.intent.getComponent().getPackageName() : shortcut.intent.getPackage();</span><br><span class="line">            <span class="keyword">if</span> (!TextUtils.isEmpty(packageName)) &#123;</span><br><span class="line">                onClickPendingAppItem(v, packageName,</span><br><span class="line">                        shortcut.hasStatusFlag(ShortcutInfo.FLAG_INSTALL_SESSION_ACTIVE));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 启动Activity</span></span><br><span class="line">        startAppShortcutOrInfoActivity(v);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里调用了startAppShortcutOrInfoActivity方法，之后的调用分别为startAppShortcutOrInfoActivity到startActivitySafely方法，在startActivitySafely方法里的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startActivitySafely</span><span class="params">(View v, Intent intent, ItemInfo item)</span> </span>&#123;</span><br><span class="line">        ······</span><br><span class="line">        <span class="comment">//启动新的任务栈</span></span><br><span class="line">        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">            intent.setSourceBounds(getViewBounds(v));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ······</span><br><span class="line">            <span class="keyword">if</span> (user == <span class="keyword">null</span> || user.equals(Process.myUserHandle())) &#123;</span><br><span class="line">                <span class="comment">// 启动活动</span></span><br><span class="line">                startActivity(intent, optsBundle);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                LauncherAppsCompat.getInstance(<span class="keyword">this</span>).startActivityForProfile(</span><br><span class="line">                        intent.getComponent(), user, intent.getSourceBounds(), optsBundle);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ActivityNotFoundException|SecurityException e) &#123;</span><br><span class="line">           ······</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Launcher继承于Activity类，而Activity类实现了startActivity函数，因此，这里就调用了Activity.startActivity函数,看看startActivity干了什么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Activity</span> <span class="keyword">extends</span> <span class="title">ContextThemeWrapper</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">LayoutInflater</span>.<span class="title">Factory</span>,</span></span><br><span class="line"><span class="class">        <span class="title">Window</span>.<span class="title">Callback</span>, <span class="title">KeyEvent</span>.<span class="title">Callback</span>,</span></span><br><span class="line"><span class="class">        <span class="title">OnCreateContextMenuListener</span>, <span class="title">ComponentCallbacks</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        startActivityForResult(intent, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(Intent intent, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//mParent是一个activity对象，此时条件成立</span></span><br><span class="line">        <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用 Instrumentation 的 execStartActivity 方法</span></span><br><span class="line">            Instrumentation.ActivityResult ar =</span><br><span class="line">                mInstrumentation.execStartActivity(</span><br><span class="line">                <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>,</span><br><span class="line">                intent, requestCode);</span><br><span class="line">            <span class="keyword">if</span> (ar != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mMainThread.sendActivityResult(</span><br><span class="line">                mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class="line">                ar.getResultData());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时requestCode =-1</span></span><br><span class="line">        <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            mStartedActivity = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         cancelInputsAndStartExitTransition(options);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mParent.startActivityFromChild(<span class="keyword">this</span>, intent, requestCode, options);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mParent.startActivityFromChild(<span class="keyword">this</span>, intent, requestCode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityFromChild</span><span class="params">(@NonNull Activity child, @RequiresPermission Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> requestCode, @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        Instrumentation.ActivityResult ar =</span><br><span class="line">            mInstrumentation.execStartActivity(</span><br><span class="line">                <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, child,</span><br><span class="line">                intent, requestCode, options);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到在startActivity方法里，直接调用了startActivityForResult方法，传入的-1表示不需要这个Actvity结束后的返回结果，再接着看startActivityForResult方法，这里有一个mParent字段，它是个什么东东呢，他其实是一个Activity对象，因为是第一次启动，所以这个mParent肯定为空，然后执行了Instrumentation.ActivityResult的execStartActivity方法，即使mParent不为空，调用的startActivityFromChild方法内也调用的是Instrumentation.ActivityResult的execStartActivity方法。ActivityResult是Instrumentation的内部类，代表着Activity的启动结果数据，而Instrumentation的作用则是监控整个APP运行流程、交互流程。这一点可以通过源码上的注释发现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base class for implementing application instrumentation code.  When running</span></span><br><span class="line"><span class="comment"> * with instrumentation turned on, this class will be instantiated for you</span></span><br><span class="line"><span class="comment"> * before any of the application code, allowing you to monitor all of the</span></span><br><span class="line"><span class="comment"> * interaction the system has with the application.  An Instrumentation</span></span><br><span class="line"><span class="comment"> * implementation is described to the system through an AndroidManifest.xml's</span></span><br><span class="line"><span class="comment"> * &amp;lt;instrumentation&amp;gt; tag.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Instrumentation</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description of a Activity execution result to return to the original</span></span><br><span class="line"><span class="comment"> * activity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityResult</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<p>那么这个execStartActivity方法里又做了什么呢，再看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mActivityMonitors != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mSync) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> N = mActivityMonitors.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> ActivityMonitor am = mActivityMonitors.get(i);</span><br><span class="line">                <span class="keyword">if</span> (am.match(who, <span class="keyword">null</span>, intent)) &#123;</span><br><span class="line">                    am.mHits++;</span><br><span class="line">                    <span class="comment">//当该monitor阻塞activity启动,则直接返回</span></span><br><span class="line">                    <span class="keyword">if</span> (am.isBlocking()) &#123;</span><br><span class="line">                        <span class="keyword">return</span> requestCode &gt;= <span class="number">0</span> ? am.getResult() : <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        intent.migrateExtraStreamToClipData();</span><br><span class="line">        intent.prepareToLeaveProcess();</span><br><span class="line">        <span class="keyword">int</span> result = ActivityManager.getService()</span><br><span class="line">            .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                    intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                    token, target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>,</span><br><span class="line">                    requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br><span class="line">        <span class="comment">//检查activity是否启动成功</span></span><br><span class="line">        checkStartActivityResult(result, intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failure from system"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看第一句，contextThread是一个IBinder对象，实际上它也是IApplicationThread 的实现类，IApplicationThread 继承了IInterface，简单看看： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * System private API for communicating with the application.  This is given to</span></span><br><span class="line"><span class="comment"> * the activity manager by an application  when it starts up, for the activity</span></span><br><span class="line"><span class="comment"> * manager to tell the application about things it needs to do.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@hide</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IApplicationThread</span> <span class="keyword">extends</span> <span class="title">IInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">schedulePauseActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finished, <span class="keyword">boolean</span> userLeaving,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> configChanges, <span class="keyword">boolean</span> dontReport)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scheduleStopActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> showWindow,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> configChanges)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scheduleWindowVisibility</span><span class="params">(IBinder token, <span class="keyword">boolean</span> showWindow)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scheduleSleeping</span><span class="params">(IBinder token, <span class="keyword">boolean</span> sleeping)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scheduleResumeActivity</span><span class="params">(IBinder token, <span class="keyword">int</span> procState, <span class="keyword">boolean</span> isForward, Bundle resumeArgs)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scheduleSendResult</span><span class="params">(IBinder token, List&lt;ResultInfo&gt; results)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scheduleLaunchActivity</span><span class="params">(Intent intent, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">            ActivityInfo info, Configuration curConfig, Configuration overrideConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">            CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> procState, Bundle state, PersistableBundle persistentState,</span></span></span><br><span class="line"><span class="function"><span class="params">            List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> notResumed, <span class="keyword">boolean</span> isForward, ProfilerInfo profilerInfo)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scheduleRelaunchActivity</span><span class="params">(IBinder token, List&lt;ResultInfo&gt; pendingResults,</span></span></span><br><span class="line"><span class="function"><span class="params">            List&lt;ReferrerIntent&gt; pendingNewIntents, <span class="keyword">int</span> configChanges, <span class="keyword">boolean</span> notResumed,</span></span></span><br><span class="line"><span class="function"><span class="params">            Configuration config, Configuration overrideConfig)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scheduleNewIntent</span><span class="params">(List&lt;ReferrerIntent&gt; intent, IBinder token)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scheduleDestroyActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finished,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> configChanges)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scheduleReceiver</span><span class="params">(Intent intent, ActivityInfo info, CompatibilityInfo compatInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> resultCode, String data, Bundle extras, <span class="keyword">boolean</span> sync,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> sendingUser, <span class="keyword">int</span> processState)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="comment">// 省略多个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scheduleBindService</span><span class="params">(IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">            Intent intent, <span class="keyword">boolean</span> rebind, <span class="keyword">int</span> processState)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scheduleUnbindService</span><span class="params">(IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">            Intent intent)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="comment">//省略多个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scheduleStopService</span><span class="params">(IBinder token)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="comment">//省略多个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bindApplication</span><span class="params">(String packageName, ApplicationInfo info, List&lt;ProviderInfo&gt; providers,</span></span></span><br><span class="line"><span class="function"><span class="params">            ComponentName testName, ProfilerInfo profilerInfo, Bundle testArguments,</span></span></span><br><span class="line"><span class="function"><span class="params">            IInstrumentationWatcher testWatcher, IUiAutomationConnection uiAutomationConnection,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> debugMode, <span class="keyword">boolean</span> openGlTrace, <span class="keyword">boolean</span> restrictedBackupMode, <span class="keyword">boolean</span> persistent,</span></span></span><br><span class="line"><span class="function"><span class="params">            Configuration config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services,</span></span></span><br><span class="line"><span class="function"><span class="params">            Bundle coreSettings)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scheduleExit</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="comment">// 省略多行代码</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scheduleRegisteredReceiver</span><span class="params">(IIntentReceiver receiver, Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> resultCode, String data, Bundle extras, <span class="keyword">boolean</span> ordered,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser, <span class="keyword">int</span> processState)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scheduleLowMemory</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scheduleActivityConfigurationChanged</span><span class="params">(IBinder token, Configuration overrideConfig)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">  <span class="comment">//省略多个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scheduleTrimMemory</span><span class="params">(<span class="keyword">int</span> level)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">  <span class="comment">//省略多个方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这些方法，例如schedulePauseActivity，scheduleResumeActivity等，我们不难发现这个IApplicationThread好像与Activity的生命周期相关，而scheduleBindService、scheduleUnbindService等方法由于service的绑定等操作相关，所以IApplicationThread的实现类ApplicationThread主要完成Activity、service的创建等相关操作的。</p>
<p>然后再看 ActivityManager.getService().startActivity这一块，首先看看ActivityManager.getService()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IActivityManager <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> IActivityManagerSingleton.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =</span><br><span class="line">            <span class="keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> IActivityManager <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                 <span class="comment">// 向 ServiceManager 查询一个 key 为 Context.ACTIVITY_SERVICE" 的引用</span></span><br><span class="line">                    <span class="keyword">final</span> IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);</span><br><span class="line">                    <span class="keyword">final</span> IActivityManager am = IActivityManager.Stub.asInterface(b);</span><br><span class="line">                    <span class="keyword">return</span> am;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">\android\out\target\common\obj\JAVA_LIBRARIES\framework_intermediates\core\java\android\app\IActivityManager.java</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> android.app.<span class="function">IActivityManager <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((obj==<span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">    <span class="keyword">if</span> (((iin!=<span class="keyword">null</span>)&amp;&amp;(iin <span class="keyword">instanceof</span> android.app.IActivityManager))) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((android.app.IActivityManager)iin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> android.app.IActivityManager.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过源码我们看到返回的是一个IActivitryManager，首先需要从ServiceManager中通过Context.ACTIVITY_SERVICE的一个字符串作为Key去查询（在ServiceManager中注册过的service会通过一个Map保存），然后返回了一个IBinder，然后又通过AIDL的方式，调用了IActivityManager.Stub.asInterface(b)方法返回一个IActivitryManager。需要注意的是，这里返回的代理对象并不是原来版本的ActivityManagerProxy对象，因为在API26之后就不再有ActivityManagerProxy这个类了，并且ActivityManagerNative也将被废弃，现在的AMN已经没有多少代码了，这里返回的应该是IActivityManager.Stub的内部类对象IActivityManager.Stub.Proxy，通过AIDL的方式在编译时会产生IActivityManager.java文件。那么这里最终是由谁去执行startActivity方法的呢，显然他应该是IActivityManager的实现类，没错就是ActivityManagerService。这样，IActivityManager.Stub与相当于一个Binder的客户端而ActivityManagerService相当于Binder的服务端，这样当IActivityManager.Stub.Proxy调用接口方法的时候底层通过Binder driver就会将请求数据与请求传递给server端，并在server端执行具体的接口逻辑。</p>
<p>在看AMS的startActivity之前，我们还要看看这个checkStartActivityResult方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkStartActivityResult</span><span class="params">(<span class="keyword">int</span> res, Object intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!ActivityManager.isStartResultFatalError(res)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (res) &#123;</span><br><span class="line">            <span class="keyword">case</span> ActivityManager.START_INTENT_NOT_RESOLVED:</span><br><span class="line">            <span class="keyword">case</span> ActivityManager.START_CLASS_NOT_FOUND:</span><br><span class="line">                <span class="keyword">if</span> (intent <span class="keyword">instanceof</span> Intent &amp;&amp; ((Intent)intent).getComponent() != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ActivityNotFoundException(</span><br><span class="line">                            <span class="string">"Unable to find explicit activity class "</span></span><br><span class="line">                            + ((Intent)intent).getComponent().toShortString()</span><br><span class="line">                            + <span class="string">"; have you declared this activity in your AndroidManifest.xml?"</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ActivityNotFoundException(</span><br><span class="line">                        <span class="string">"No Activity found to handle "</span> + intent);</span><br><span class="line">            <span class="keyword">case</span> ActivityManager.START_PERMISSION_DENIED:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Not allowed to start activity "</span></span><br><span class="line">                        + intent);</span><br><span class="line">            <span class="keyword">case</span> ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(</span><br><span class="line">                        <span class="string">"FORWARD_RESULT_FLAG used while also requesting a result"</span>);</span><br><span class="line">            <span class="keyword">case</span> ActivityManager.START_NOT_ACTIVITY:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        <span class="string">"PendingIntent is not an activity"</span>);</span><br><span class="line">            <span class="keyword">case</span> ActivityManager.START_NOT_VOICE_COMPATIBLE:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                        <span class="string">"Starting under voice control not allowed for: "</span> + intent);</span><br><span class="line">            <span class="keyword">case</span> ActivityManager.START_VOICE_NOT_ACTIVE_SESSION:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                        <span class="string">"Session calling startVoiceActivity does not match active session"</span>);</span><br><span class="line">            <span class="keyword">case</span> ActivityManager.START_VOICE_HIDDEN_SESSION:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                        <span class="string">"Cannot start voice activity on a hidden session"</span>);</span><br><span class="line">            <span class="keyword">case</span> ActivityManager.START_ASSISTANT_NOT_ACTIVE_SESSION:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                        <span class="string">"Session calling startAssistantActivity does not match active session"</span>);</span><br><span class="line">            <span class="keyword">case</span> ActivityManager.START_ASSISTANT_HIDDEN_SESSION:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                        <span class="string">"Cannot start assistant activity on a hidden session"</span>);</span><br><span class="line">            <span class="keyword">case</span> ActivityManager.START_CANCELED:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(<span class="string">"Activity could not be started for "</span></span><br><span class="line">                        + intent);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(<span class="string">"Unknown error code "</span></span><br><span class="line">                        + res + <span class="string">" when starting "</span> + intent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>顾名思义这个方法就是用来检查启动Activity的，代码中也可以很清晰的发现，这里会抛出各种比如异常，比如我们没有在AndroidManifest中声明activity就会抛出这个ActivityNotFoundException，提示have you declared this activity in your AndroidManifest.xml。</p>
<h2 id="AMS——zygote过程"><a href="#AMS——zygote过程" class="headerlink" title="AMS——zygote过程"></a>AMS——zygote过程</h2><p>获取了ActivityManager的服务(AMS)来启动Activity后，我们就要来看他的实现类AMS的startActivity方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityManagerService</span> <span class="keyword">extends</span> <span class="title">IActivityManager</span>.<span class="title">Stub</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Watchdog</span>.<span class="title">Monitor</span>, <span class="title">BatteryStatsImpl</span>.<span class="title">BatteryCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Priority we boost main thread and RT of top app to.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TOP_APP_PRIORITY_BOOST = -<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = TAG_WITH_CLASS_NAME ? <span class="string">"ActivityManagerService"</span> : TAG_AM;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG_BACKUP = TAG + POSTFIX_BACKUP;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">            Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">                resultWho, requestCode, startFlags, profilerInfo, bOptions,</span><br><span class="line">                UserHandle.getCallingUserId());   <span class="comment">//注释1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">            Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">                resultWho, requestCode, startFlags, profilerInfo, bOptions, userId,</span><br><span class="line">                <span class="keyword">true</span> <span class="comment">/*validateIncomingUser*/</span>);   <span class="comment">//注释2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">            Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions, <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> validateIncomingUser)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//确定进程是否被隔离了 隔离了就直接抛异常</span></span><br><span class="line">        enforceNotIsolatedCaller(<span class="string">"startActivity"</span>);   <span class="comment">//注释3</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">//检查启动Activity的userId是否是合法的</span></span><br><span class="line">        userId = mActivityStartController.checkTargetUser(userId, validateIncomingUser,</span><br><span class="line">                Binder.getCallingPid(), Binder.getCallingUid(), <span class="string">"startActivityAsUser"</span>);    <span class="comment">//注释4</span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Switch to user app stacks here.</span></span><br><span class="line">        <span class="keyword">return</span> mActivityStartController.obtainStarter(intent, <span class="string">"startActivityAsUser"</span>)   <span class="comment">//注释5</span></span><br><span class="line">                .setCaller(caller)</span><br><span class="line">                .setCallingPackage(callingPackage)</span><br><span class="line">                .setResolvedType(resolvedType)</span><br><span class="line">                .setResultTo(resultTo)</span><br><span class="line">                .setResultWho(resultWho)</span><br><span class="line">                .setRequestCode(requestCode)</span><br><span class="line">                .setStartFlags(startFlags)</span><br><span class="line">                .setProfilerInfo(profilerInfo)</span><br><span class="line">                .setActivityOptions(bOptions)</span><br><span class="line">                .setMayWait(userId)</span><br><span class="line">                .execute();     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先在startActivity方法中又直接调用了父类的startActivityAsUser，最后调用自己的startActivityAsUser方法，注释3处会检查该进程是否被隔离了，然后检查启动activity的userId是否合法，最后进行了一长串的链式调用，我们看最后的execute方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Controller for interpreting how and then launching an activity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This class collects all the logic for determining how an intent and flags should be turned into</span></span><br><span class="line"><span class="comment"> * an activity and associated task and stack.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActivityStarter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Starts an activity based on the request parameters provided earlier.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The starter result.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// TODO(b/64750076): Look into passing request directly to these methods to allow</span></span><br><span class="line">            <span class="comment">// for transactional diffs and preprocessing.</span></span><br><span class="line">            <span class="keyword">if</span> (mRequest.mayWait) &#123;   </span><br><span class="line">                <span class="keyword">return</span> startActivityMayWait(mRequest.caller, mRequest.callingUid,    <span class="comment">//注释1</span></span><br><span class="line">                        mRequest.callingPackage, mRequest.intent, mRequest.resolvedType,</span><br><span class="line">                        mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,</span><br><span class="line">                        mRequest.resultWho, mRequest.requestCode, mRequest.startFlags,</span><br><span class="line">                        mRequest.profilerInfo, mRequest.waitResult, mRequest.globalConfig,</span><br><span class="line">                        mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.userId,</span><br><span class="line">                        mRequest.inTask, mRequest.reason,</span><br><span class="line">                        mRequest.allowPendingRemoteAnimationRegistryLookup);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> startActivity(mRequest.caller, mRequest.intent,     <span class="comment">//注释2</span></span><br><span class="line">                mRequest.ephemeralIntent,</span><br><span class="line">                        mRequest.resolvedType, mRequest.activityInfo, mRequest.resolveInfo,</span><br><span class="line">                        mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,</span><br><span class="line">                        mRequest.resultWho, mRequest.requestCode, mRequest.callingPid,</span><br><span class="line">                        mRequest.callingUid, mRequest.callingPackage, mRequest.realCallingPid,</span><br><span class="line">                        mRequest.realCallingUid, mRequest.startFlags, mRequest.activityOptions,</span><br><span class="line">                        mRequest.ignoreTargetSecurity, mRequest.componentSpecified,</span><br><span class="line">                        mRequest.outActivity, mRequest.inTask, mRequest.reason,</span><br><span class="line">                        mRequest.allowPendingRemoteAnimationRegistryLookup);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            onExecutionComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个判断，他会返回true，为什么呢，在之前链式调用setMayWait方法时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ActivityStarter <span class="title">setMayWait</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        mRequest.mayWait = <span class="keyword">true</span>;</span><br><span class="line">        mRequest.userId = userId;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可见，下一步会调用startActivityMayWait方法，内部调用了startActivityLocked方法，然后进入startActivity方法，之后又调用了startActivityUnchecked方法，然后调用了ActivityStackSupervisor#resumeFocusedStackTopActivityLocked，这个时候启动过程就从ActivityStarter 转移到ActivityStackSupervisor，源码调用过程如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivityMayWait</span><span class="params">(IApplicationThread caller, <span class="keyword">int</span> callingUid,</span></span></span><br><span class="line"><span class="function"><span class="params">            String callingPackage, Intent intent, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">            IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">            ProfilerInfo profilerInfo, WaitResult outResult,</span></span></span><br><span class="line"><span class="function"><span class="params">            Configuration globalConfig, SafeActivityOptions options, <span class="keyword">boolean</span> ignoreTargetSecurity,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> userId, TaskRecord inTask, String reason,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> allowPendingRemoteAnimationRegistryLookup)</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">// 获得调用者的uid和pid</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> realCallingPid = Binder.getCallingPid();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> realCallingUid = Binder.getCallingUid();</span><br><span class="line">    ···</span><br><span class="line">     <span class="comment">// 从PackageManagerService处获取应用信息，PackageManagerService会解析应用的AndroidManifest.xml文件</span></span><br><span class="line">     <span class="comment">//然后把应用信息保存</span></span><br><span class="line">    ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId,</span><br><span class="line">            <span class="number">0</span> <span class="comment">/* matchFlags */</span>,computeResolveFilterUid(</span><br><span class="line">            callingUid, realCallingUid, mRequest.filterCallingUid));</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">if</span> (rInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据ResolveInfo取得ActivityInfo，ActivityInfo保存着Activity的基本信息</span></span><br><span class="line">    <span class="comment">// Collect information about the target of the Intent.</span></span><br><span class="line">    ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo);</span><br><span class="line">    ···</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> ActivityRecord[] outRecord = <span class="keyword">new</span> ActivityRecord[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 调用startActivity</span></span><br><span class="line">    <span class="keyword">int</span> res = startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo,</span><br><span class="line">                    voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid,</span><br><span class="line">                    callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options,</span><br><span class="line">                    ignoreTargetSecurity, componentSpecified, outRecord, inTask, reason,</span><br><span class="line">                    allowPendingRemoteAnimationRegistryLookup);</span><br><span class="line"></span><br><span class="line">    Binder.restoreCallingIdentity(origId);</span><br><span class="line">    ···</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (outResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">       	   <span class="comment">// 处理返回结果</span></span><br><span class="line">           ...</span><br><span class="line">	&#125;</span><br><span class="line">    mSupervisor.getActivityMetricsLogger().notifyActivityLaunched(res, outRecord[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">                IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask,</span></span></span><br><span class="line"><span class="function"><span class="params">                ActivityRecord[] outActivity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = START_CANCELED;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mService.mWindowManager.deferSurfaceLayout();</span><br><span class="line">            result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,</span><br><span class="line">                    startFlags, doResume, options, inTask, outActivity);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// If we are not able to proceed, disassociate the activity from the task. Leaving an</span></span><br><span class="line">            <span class="comment">// activity in an incomplete state can lead to issues, such as performing operations</span></span><br><span class="line">            <span class="comment">// without a window container.</span></span><br><span class="line">            <span class="keyword">final</span> ActivityStack stack = mStartActivity.getStack();</span><br><span class="line">            <span class="keyword">if</span> (!ActivityManager.isStartResultSuccessful(result) &amp;&amp; stack != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.finishActivityLocked(mStartActivity, RESULT_CANCELED,</span><br><span class="line">                        <span class="keyword">null</span> <span class="comment">/* intentResultData */</span>, <span class="string">"startActivity"</span>, <span class="keyword">true</span> <span class="comment">/* oomAdj */</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mService.mWindowManager.continueSurfaceLayout();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        postStartActivityProcessing(r, result, mTargetStack);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note: This method should only be called from &#123;@link startActivity&#125;.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivityUnchecked</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask,</span></span></span><br><span class="line"><span class="function"><span class="params">            ActivityRecord[] outActivity)</span> </span>&#123;</span><br><span class="line">    ···             </span><br><span class="line">  mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,</span><br><span class="line">                        mOptions);</span><br><span class="line"></span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在又看ActivityStackSupervisor#resumeFocusedStackTopActivityLocked方法又是如何运作的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeFocusedStackTopActivityLocked</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!readyToResume()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (targetStack != <span class="keyword">null</span> &amp;&amp; isFocusedStack(targetStack)) &#123;</span><br><span class="line">            <span class="keyword">return</span> targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ActivityRecord r = mFocusedStack.topRunningActivityLocked();</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="keyword">null</span> || !r.isState(RESUMED)) &#123;</span><br><span class="line">            mFocusedStack.resumeTopActivityUncheckedLocked(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.isState(RESUMED)) &#123;</span><br><span class="line">            <span class="comment">// Kick off any lingering app transitions form the MoveTaskToFront operation.</span></span><br><span class="line">            mFocusedStack.executeAppTransition(targetOptions);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里它调用了ActivityStack的resumeTopActivityUncheckedLocked方法，又回到了ActivityStack里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeTopActivityUncheckedLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mStackSupervisor.inResumeTopActivity) &#123;</span><br><span class="line">            <span class="comment">// Don't even start recursing.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Protect against recursion.</span></span><br><span class="line">            mStackSupervisor.inResumeTopActivity = <span class="keyword">true</span>;</span><br><span class="line">            result = resumeTopActivityInnerLocked(prev, options);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// When resuming the top activity, it may be necessary to pause the top activity (for</span></span><br><span class="line">            <span class="comment">// example, returning to the lock screen. We suppress the normal pause logic in</span></span><br><span class="line">            <span class="comment">// &#123;@link #resumeTopActivityUncheckedLocked&#125;, since the top activity is resumed at the</span></span><br><span class="line">            <span class="comment">// end. We call the &#123;@link ActivityStackSupervisor#checkReadyForSleepLocked&#125; again here</span></span><br><span class="line">            <span class="comment">// to ensure any necessary pause logic occurs. In the case where the Activity will be</span></span><br><span class="line">            <span class="comment">// shown regardless of the lock screen, the call to</span></span><br><span class="line">            <span class="comment">// &#123;@link ActivityStackSupervisor#checkReadyForSleepLocked&#125; is skipped.</span></span><br><span class="line">            <span class="keyword">final</span> ActivityRecord next = topRunningActivityLocked(<span class="keyword">true</span> <span class="comment">/* focusableOnly */</span>);</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span> || !next.canTurnScreenOn()) &#123;</span><br><span class="line">                checkReadyForSleep();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mStackSupervisor.inResumeTopActivity = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法又调用了自身的resumeTopActivityInnerLocked方法，这个方法特别长，我们仔细看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">resumeTopActivityInnerLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (!mService.mBooting &amp;&amp; !mService.mBooted) &#123;</span><br><span class="line">       <span class="comment">// Not ready yet!</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取TaskRecord的栈顶Activity，如果正常的话这个ActivityRecord为待启动的Activity </span></span><br><span class="line">   <span class="comment">// Find the next top-most activity to resume in this stack that is not finishing and is</span></span><br><span class="line">   <span class="comment">// focusable. If it is not focusable, we will fall into the case below to resume the</span></span><br><span class="line">   <span class="comment">// top activity in the next focusable task.</span></span><br><span class="line">   <span class="keyword">final</span> ActivityRecord next = topRunningActivityLocked(<span class="keyword">true</span> <span class="comment">/* focusableOnly */</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">boolean</span> hasRunningActivity = next != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 将待启动的Activity从下面几个队列中移除</span></span><br><span class="line">   <span class="comment">// The activity may be waiting for stop, but that is no longer</span></span><br><span class="line">   <span class="comment">// appropriate for it.</span></span><br><span class="line">   mStackSupervisor.mStoppingActivities.remove(next);</span><br><span class="line">   mStackSupervisor.mGoingToSleepActivities.remove(next);</span><br><span class="line">   next.sleeping = <span class="keyword">false</span>;</span><br><span class="line">   mStackSupervisor.mActivitiesWaitingForVisibleActivity.remove(next);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (DEBUG_SWITCH) Slog.v(TAG_SWITCH, <span class="string">"Resuming "</span> + next);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果系统当前正在中断一个Activity，需要先等待那个Activity pause完毕，之后系统会重新调用resumeTopActivityInnerLocked函数，找到下一个要启动的Activity</span></span><br><span class="line">   <span class="comment">// If we are currently pausing an activity, then don't do anything until that is done.</span></span><br><span class="line">   <span class="keyword">if</span> (!mStackSupervisor.allPausedActivitiesComplete()) &#123;</span><br><span class="line">       <span class="keyword">if</span> (DEBUG_SWITCH || DEBUG_PAUSE || DEBUG_STATES) Slog.v(TAG_PAUSE,</span><br><span class="line">               <span class="string">"resumeTopActivityLocked: Skip resume: some activity pausing."</span>);</span><br><span class="line">       <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   <span class="keyword">boolean</span> pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, <span class="keyword">false</span>);</span><br><span class="line">   <span class="comment">// mResumedActivity指向上一次启动的Activity，也就是当前界面显示的Activity</span></span><br><span class="line">   <span class="keyword">if</span> (mResumedActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">// 如果当前界面显示了一个Activity，那么在启动新的Activity之前</span></span><br><span class="line">       <span class="comment">// 必须中断当前的Activity,也就是调用当前Activity的onPause函数</span></span><br><span class="line">       <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">               <span class="string">"resumeTopActivityLocked: Pausing "</span> + mResumedActivity);</span><br><span class="line">       pausing |= startPausingLocked(userLeaving, <span class="keyword">false</span>, next, <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (pausing &amp;&amp; !resumeWhilePausing) &#123;</span><br><span class="line">       <span class="comment">//如果系统正在中断当前启动的Activity，并且未设置FLAG_RESUME_WHILE_PAUSING标签则会  </span></span><br><span class="line">       <span class="comment">//进入该分支，等当前Activity中断完成之后会重新调用resumeTopActivityInnerLocked函数</span></span><br><span class="line">       <span class="keyword">if</span> (DEBUG_SWITCH || DEBUG_STATES) Slog.v(TAG_STATES,</span><br><span class="line">               <span class="string">"resumeTopActivityLocked: Skip resume: need to start pausing"</span>);</span><br><span class="line">       <span class="comment">// At this point we want to put the upcoming activity's process</span></span><br><span class="line">       <span class="comment">// at the top of the LRU list, since we know we will be needing it</span></span><br><span class="line">       <span class="comment">// very soon and it would be a waste to let it get killed if it</span></span><br><span class="line">       <span class="comment">// happens to be sitting towards the end.</span></span><br><span class="line">       <span class="keyword">if</span> (next.app != <span class="keyword">null</span> &amp;&amp; next.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 在中断当前界面的Activity时，调整待启动Activity所在进程的优先级，保证其不被kill</span></span><br><span class="line">           mService.updateLruProcessLocked(next.app, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">       <span class="keyword">if</span> (lastResumed != <span class="keyword">null</span>) &#123;</span><br><span class="line">           lastResumed.setWillCloseOrEnterPip(<span class="keyword">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mResumedActivity == next &amp;&amp; next.isState(RESUMED)</span><br><span class="line">           &amp;&amp; mStackSupervisor.allResumedActivitiesComplete()) &#123;</span><br><span class="line">       <span class="comment">// It is possible for the activity to be resumed when we paused back stacks above if the</span></span><br><span class="line">       <span class="comment">// next activity doesn't have to wait for pause to complete.</span></span><br><span class="line">       <span class="comment">// So, nothing else to-do except:</span></span><br><span class="line">       <span class="comment">// Make sure we have executed any pending transitions, since there</span></span><br><span class="line">       <span class="comment">// should be nothing left to do at this point.</span></span><br><span class="line">       executeAppTransition(options);</span><br><span class="line">       <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">               <span class="string">"resumeTopActivityLocked: Top activity resumed (dontWaitForPause) "</span> + next);</span><br><span class="line">       <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 若之前存在未正常结束的Activity，那么要优先结束掉这些Activity</span></span><br><span class="line">   <span class="comment">// If the most recent activity was noHistory but was only stopped rather</span></span><br><span class="line">   <span class="comment">// than stopped+finished because the device went to sleep, we need to make</span></span><br><span class="line">   <span class="comment">// sure to finish it as we're making a new activity topmost.</span></span><br><span class="line">   <span class="keyword">if</span> (shouldSleepActivities() &amp;&amp; mLastNoHistoryActivity != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">           !mLastNoHistoryActivity.finishing) &#123;</span><br><span class="line">       <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">               <span class="string">"no-history finish of "</span> + mLastNoHistoryActivity + <span class="string">" on new resume"</span>);</span><br><span class="line">       requestFinishActivityLocked(mLastNoHistoryActivity.appToken, Activity.RESULT_CANCELED,</span><br><span class="line">               <span class="keyword">null</span>, <span class="string">"resume-no-history"</span>, <span class="keyword">false</span>);</span><br><span class="line">       mLastNoHistoryActivity = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">   ActivityStack lastStack = mStackSupervisor.getLastStack();</span><br><span class="line">   <span class="keyword">if</span> (next.app != <span class="keyword">null</span> &amp;&amp; next.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">// 如果待启动的Activity已有对应的进程存在，则只需要重启Activity</span></span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// Whoops, need to restart this activity!</span></span><br><span class="line">       <span class="keyword">if</span> (!next.hasBeenLaunched) &#123;</span><br><span class="line">           next.hasBeenLaunched = <span class="keyword">true</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (SHOW_APP_STARTING_PREVIEW) &#123;</span><br><span class="line">               next.showStartingWindow(<span class="keyword">null</span> <span class="comment">/* prev */</span>, <span class="keyword">false</span> <span class="comment">/* newTask */</span>,</span><br><span class="line">                       <span class="keyword">false</span> <span class="comment">/* taskSwich */</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (DEBUG_SWITCH) Slog.v(TAG_SWITCH, <span class="string">"Restarting: "</span> + next);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES, <span class="string">"resumeTopActivityLocked: Restarting "</span> + next);</span><br><span class="line">       <span class="comment">//如果待启动的Activity进程不存在则调用ActivityStackSupervisor的startSpecificActivityLocked函数，启动整个进程</span></span><br><span class="line">       mStackSupervisor.startSpecificActivityLocked(next, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;！</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法比较长，但是也可以清楚的发现些比较关键的地方：</p>
<ul>
<li>如果mResumedActivity不为空，则需要先暂停这个Activity。mResumedActivity代表当前已经存在于界面的Activity。当需要启动一个新的Activity时，需要先停止当前的Activity。这部分工作由startPausingLocked函数来完成。当前的Activity被中断后，将重新启动新的Activity。</li>
<li>当mResumedActivity为空时，若待启动的Activity对应的进程已经存在，那么仅需要重新启动该Activity；否则，需要调用ActivityStackSupervisor的startSpecificActivityLocked函数，启动整个进程：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startSpecificActivityLocked</span><span class="params">(ActivityRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Is this activity's application already running?</span></span><br><span class="line">        ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class="line">                r.info.applicationInfo.uid, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        getLaunchTimeTracker().setLaunchTime(r);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == <span class="number">0</span></span><br><span class="line">                        || !<span class="string">"android"</span>.equals(r.info.packageName)) &#123;</span><br><span class="line">                    <span class="comment">// Don't add this if it is a platform component that is marked</span></span><br><span class="line">                    <span class="comment">// to run in multiple processes, because this is actually</span></span><br><span class="line">                    <span class="comment">// part of the framework so doesn't make sense to track as a</span></span><br><span class="line">                    <span class="comment">// separate apk in the process.</span></span><br><span class="line">                    app.addPackage(r.info.packageName, r.info.applicationInfo.longVersionCode,</span><br><span class="line">                            mService.mProcessStats);</span><br><span class="line">                &#125;</span><br><span class="line">                realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Exception when starting activity "</span></span><br><span class="line">                        + r.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If a dead object exception was thrown -- fall through to</span></span><br><span class="line">            <span class="comment">// restart the application.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class="keyword">true</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="string">"activity"</span>, r.intent.getComponent(), <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的内部实现可以发现它的作用是根据app进程是否存在来调用不同的方法，当app进程已经存在就直接调用了realStartActivityLocked方法，否则调用startProcessLocked方法，顾名思义这个方法将用于app进程的创建，当然真正的创建工作并不是他完成的，想知道他是在哪实现的，还需要知道mService是什么，通过构造方法我们发现，其实就是AMS：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ActivityStackSupervisor</span><span class="params">(ActivityManagerService service, Looper looper)</span> </span>&#123;</span><br><span class="line">        mService = service;</span><br><span class="line">        mLooper = looper;</span><br><span class="line">        mHandler = <span class="keyword">new</span> ActivityStackSupervisorHandler(looper);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>所以我们需要到AMS里去看看是如何实现的(4个重载方法，代码很长)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ProcessRecord <span class="title">startProcessLocked</span><span class="params">(String processName,</span></span></span><br><span class="line"><span class="function"><span class="params">            ApplicationInfo info, <span class="keyword">boolean</span> knownToBeDead, <span class="keyword">int</span> intentFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">            String hostingType, ComponentName hostingName, <span class="keyword">boolean</span> allowWhileBooting,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> isolated, <span class="keyword">boolean</span> keepIfLarge)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType,</span><br><span class="line">                hostingName, allowWhileBooting, isolated, <span class="number">0</span> <span class="comment">/* isolatedUid */</span>, keepIfLarge,</span><br><span class="line">                <span class="keyword">null</span> <span class="comment">/* ABI override */</span>, <span class="keyword">null</span> <span class="comment">/* entryPoint */</span>, <span class="keyword">null</span> <span class="comment">/* entryPointArgs */</span>,</span><br><span class="line">                <span class="keyword">null</span> <span class="comment">/* crashHandler */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">final</span> ProcessRecord <span class="title">startProcessLocked</span><span class="params">(String processName, ApplicationInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> knownToBeDead, <span class="keyword">int</span> intentFlags, String hostingType, ComponentName hostingName,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> allowWhileBooting, <span class="keyword">boolean</span> isolated, <span class="keyword">int</span> isolatedUid, <span class="keyword">boolean</span> keepIfLarge,</span></span></span><br><span class="line"><span class="function"><span class="params">            String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = SystemClock.elapsedRealtime();</span><br><span class="line">        ProcessRecord app;</span><br><span class="line">        <span class="comment">//如果这个ProcessRecord对象没有被隔离，那么调用</span></span><br><span class="line">        <span class="comment">//getProcessRecordLocked方法获取</span></span><br><span class="line">        <span class="comment">//否则为空</span></span><br><span class="line">        <span class="keyword">if</span> (!isolated) &#123;</span><br><span class="line">            <span class="comment">// 根据processName和uid寻找是否已经存在processRecord</span></span><br><span class="line">            app = getProcessRecordLocked(processName, info.uid, keepIfLarge);</span><br><span class="line">            checkTime(startTime, <span class="string">"startProcess: after getProcessRecord"</span>);</span><br><span class="line">           ···</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// If this is an isolated process, it can't re-use an existing process.</span></span><br><span class="line">            app = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         ···</span><br><span class="line">        String hostingNameStr = hostingName != <span class="keyword">null</span></span><br><span class="line">                ? hostingName.flattenToShortString() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果app为空，则直接创建</span></span><br><span class="line">        <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkTime(startTime, <span class="string">"startProcess: creating new process record"</span>);</span><br><span class="line">            app = newProcessRecordLocked(info, processName, isolated, isolatedUid);</span><br><span class="line">            <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Failed making new process record for "</span></span><br><span class="line">                        + processName + <span class="string">"/"</span> + info.uid + <span class="string">" isolated="</span> + isolated);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            app.crashHandler = crashHandler;</span><br><span class="line">            app.isolatedEntryPoint = entryPoint;</span><br><span class="line">            app.isolatedEntryPointArgs = entryPointArgs;</span><br><span class="line">            checkTime(startTime, <span class="string">"startProcess: done creating new process record"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// If this is a new package in the process, add the package to the list</span></span><br><span class="line">            app.addPackage(info.packageName, info.versionCode, mProcessStats);</span><br><span class="line">            checkTime(startTime, <span class="string">"startProcess: added package to existing proc"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ···</span><br><span class="line">        checkTime(startTime, <span class="string">"startProcess: stepping in to startProcess"</span>);</span><br><span class="line">        <span class="comment">//创建是否成功的结果交给另一个startProcessLocked重载</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> success = startProcessLocked(app, hostingType, hostingNameStr, abiOverride);</span><br><span class="line">        checkTime(startTime, <span class="string">"startProcess: done starting proc!"</span>);</span><br><span class="line">        <span class="keyword">return</span> success ? app : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">            String hostingType, String hostingNameStr)</span> </span>&#123;</span><br><span class="line">        startProcessLocked(app, hostingType, hostingNameStr, <span class="keyword">null</span> <span class="comment">/* abiOverride */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">            String hostingType, String hostingNameStr, String abiOverride)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startProcessLocked(app, hostingType, hostingNameStr,</span><br><span class="line">                <span class="keyword">false</span> <span class="comment">/* disableHiddenApiChecks */</span>, abiOverride);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if process start is successful, false otherwise.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app, String hostingType,</span></span></span><br><span class="line"><span class="function"><span class="params">            String hostingNameStr, <span class="keyword">boolean</span> disableHiddenApiChecks, String abiOverride)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (app.pendingStart) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> startTime = SystemClock.elapsedRealtime();</span><br><span class="line">        <span class="keyword">if</span> (app.pid &gt; <span class="number">0</span> &amp;&amp; app.pid != MY_PID) &#123;</span><br><span class="line">            checkTime(startTime, <span class="string">"startProcess: removing from pids map"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line">                mPidsSelfLocked.remove(app.pid);</span><br><span class="line">                mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);</span><br><span class="line">            &#125;</span><br><span class="line">            checkTime(startTime, <span class="string">"startProcess: done removing from pids map"</span>);</span><br><span class="line">            app.setPid(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ···</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> userId = UserHandle.getUserId(app.uid);</span><br><span class="line">                AppGlobals.getPackageManager().checkPackageStartable(app.info.packageName, userId);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.rethrowAsRuntimeException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> uid = app.uid;</span><br><span class="line">            <span class="keyword">int</span>[] gids = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> mountExternal = Zygote.MOUNT_EXTERNAL_NONE;</span><br><span class="line">            <span class="keyword">if</span> (!app.isolated) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] permGids = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    checkTime(startTime, <span class="string">"startProcess: getting gids from package manager"</span>);</span><br><span class="line">                    <span class="keyword">final</span> IPackageManager pm = AppGlobals.getPackageManager();</span><br><span class="line">                    permGids = pm.getPackageGids(app.info.packageName,</span><br><span class="line">                            MATCH_DEBUG_TRIAGED_MISSING, app.userId);</span><br><span class="line">                    StorageManagerInternal storageManagerInternal = LocalServices.getService(</span><br><span class="line">                            StorageManagerInternal.class);</span><br><span class="line">                    mountExternal = storageManagerInternal.getExternalStorageMountMode(uid,</span><br><span class="line">                            app.info.packageName);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e.rethrowAsRuntimeException();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Add shared application and profile GIDs so applications can share some</span></span><br><span class="line"><span class="comment">                 * resources like shared libraries and access user-wide resources</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (ArrayUtils.isEmpty(permGids)) &#123;</span><br><span class="line">                    gids = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    gids = <span class="keyword">new</span> <span class="keyword">int</span>[permGids.length + <span class="number">3</span>];</span><br><span class="line">                    System.arraycopy(permGids, <span class="number">0</span>, gids, <span class="number">3</span>, permGids.length);</span><br><span class="line">                &#125;</span><br><span class="line">                gids[<span class="number">0</span>] = UserHandle.getSharedAppGid(UserHandle.getAppId(uid));</span><br><span class="line">                gids[<span class="number">1</span>] = UserHandle.getCacheAppGid(UserHandle.getAppId(uid));</span><br><span class="line">                gids[<span class="number">2</span>] = UserHandle.getUserGid(UserHandle.getUserId(uid));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Replace any invalid GIDs</span></span><br><span class="line">                <span class="keyword">if</span> (gids[<span class="number">0</span>] == UserHandle.ERR_GID) gids[<span class="number">0</span>] = gids[<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">if</span> (gids[<span class="number">1</span>] == UserHandle.ERR_GID) gids[<span class="number">1</span>] = gids[<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            checkTime(startTime, <span class="string">"startProcess: building args"</span>);</span><br><span class="line">            <span class="keyword">if</span> (mFactoryTest != FactoryTest.FACTORY_TEST_OFF) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL</span><br><span class="line">                        &amp;&amp; mTopComponent != <span class="keyword">null</span></span><br><span class="line">                        &amp;&amp; app.processName.equals(mTopComponent.getPackageName())) &#123;</span><br><span class="line">                    uid = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (mFactoryTest == FactoryTest.FACTORY_TEST_HIGH_LEVEL</span><br><span class="line">                        &amp;&amp; (app.info.flags&amp;ApplicationInfo.FLAG_FACTORY_TEST) != <span class="number">0</span>) &#123;</span><br><span class="line">                    uid = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> runtimeFlags = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> ((app.info.flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != <span class="number">0</span>) &#123;</span><br><span class="line">                runtimeFlags |= Zygote.DEBUG_ENABLE_JDWP;</span><br><span class="line">                runtimeFlags |= Zygote.DEBUG_JAVA_DEBUGGABLE;</span><br><span class="line">                <span class="comment">// Also turn on CheckJNI for debuggable apps. It's quite</span></span><br><span class="line">                <span class="comment">// awkward to turn on otherwise.</span></span><br><span class="line">                runtimeFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;</span><br><span class="line">            &#125;</span><br><span class="line">            ···</span><br><span class="line">            <span class="keyword">if</span> (mNativeDebuggingApp != <span class="keyword">null</span> &amp;&amp; mNativeDebuggingApp.equals(app.processName)) &#123;</span><br><span class="line">                <span class="comment">// Enable all debug flags required by the native debugger.</span></span><br><span class="line">                runtimeFlags |= Zygote.DEBUG_ALWAYS_JIT;          <span class="comment">// Don't interpret anything</span></span><br><span class="line">                runtimeFlags |= Zygote.DEBUG_GENERATE_DEBUG_INFO; <span class="comment">// Generate debug info</span></span><br><span class="line">                runtimeFlags |= Zygote.DEBUG_NATIVE_DEBUGGABLE;   <span class="comment">// Disbale optimizations</span></span><br><span class="line">                mNativeDebuggingApp = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (app.info.isPrivilegedApp() &amp;&amp;</span><br><span class="line">                    DexManager.isPackageSelectedToRunOob(app.pkgList.keySet())) &#123;</span><br><span class="line">                runtimeFlags |= Zygote.ONLY_USE_SYSTEM_OAT_FILES;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!disableHiddenApiChecks &amp;&amp; !mHiddenApiBlacklist.isDisabled()) &#123;</span><br><span class="line">                app.info.maybeUpdateHiddenApiEnforcementPolicy(</span><br><span class="line">                        mHiddenApiBlacklist.getPolicyForPrePApps(),</span><br><span class="line">                        mHiddenApiBlacklist.getPolicyForPApps());</span><br><span class="line">                <span class="meta">@HiddenApiEnforcementPolicy</span> <span class="keyword">int</span> policy =</span><br><span class="line">                        app.info.getHiddenApiEnforcementPolicy();</span><br><span class="line">                <span class="keyword">int</span> policyBits = (policy &lt;&lt; Zygote.API_ENFORCEMENT_POLICY_SHIFT);</span><br><span class="line">                <span class="keyword">if</span> ((policyBits &amp; Zygote.API_ENFORCEMENT_POLICY_MASK) != policyBits) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Invalid API policy: "</span> + policy);</span><br><span class="line">                &#125;</span><br><span class="line">                runtimeFlags |= policyBits;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String invokeWith = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> ((app.info.flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Debuggable apps may include a wrapper script with their library directory.</span></span><br><span class="line">                String wrapperFileName = app.info.nativeLibraryDir + <span class="string">"/wrap.sh"</span>;</span><br><span class="line">                StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">new</span> File(wrapperFileName).exists()) &#123;</span><br><span class="line">                        invokeWith = <span class="string">"/system/bin/logwrapper "</span> + wrapperFileName;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    StrictMode.setThreadPolicy(oldPolicy);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String requiredAbi = (abiOverride != <span class="keyword">null</span>) ? abiOverride : app.info.primaryCpuAbi;</span><br><span class="line">            <span class="keyword">if</span> (requiredAbi == <span class="keyword">null</span>) &#123;</span><br><span class="line">                requiredAbi = Build.SUPPORTED_ABIS[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String instructionSet = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (app.info.primaryCpuAbi != <span class="keyword">null</span>) &#123;</span><br><span class="line">                instructionSet = VMRuntime.getInstructionSet(app.info.primaryCpuAbi);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            app.gids = gids;</span><br><span class="line">            app.requiredAbi = requiredAbi;</span><br><span class="line">            app.instructionSet = instructionSet;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// the per-user SELinux context must be set</span></span><br><span class="line">            <span class="keyword">if</span> (TextUtils.isEmpty(app.info.seInfoUser)) &#123;</span><br><span class="line">                Slog.wtf(TAG, <span class="string">"SELinux tag not defined"</span>,</span><br><span class="line">                        <span class="keyword">new</span> IllegalStateException(<span class="string">"SELinux tag not defined for "</span></span><br><span class="line">                        + app.info.packageName + <span class="string">" (uid "</span> + app.uid + <span class="string">")"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> String seInfo = app.info.seInfo</span><br><span class="line">                    + (TextUtils.isEmpty(app.info.seInfoUser) ? <span class="string">""</span> : app.info.seInfoUser);</span><br><span class="line">            <span class="comment">// Start the process.  It will either succeed and return a result containing</span></span><br><span class="line">            <span class="comment">// the PID of the new process, or else throw a RuntimeException.</span></span><br><span class="line">            <span class="keyword">final</span> String entryPoint = <span class="string">"android.app.ActivityThread"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> startProcessLocked(hostingType, hostingNameStr, entryPoint, app, uid, gids,</span><br><span class="line">                    runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith,</span><br><span class="line">                    startTime);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            Slog.e(TAG, <span class="string">"Failure starting process "</span> + app.processName, e);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Something went very wrong while trying to start this process; one</span></span><br><span class="line">            <span class="comment">// common case is when the package is frozen due to an active</span></span><br><span class="line">            <span class="comment">// upgrade. To recover, clean up any active bookkeeping related to</span></span><br><span class="line">            <span class="comment">// starting this process. (We already invoked this method once when</span></span><br><span class="line">            <span class="comment">// the package was initially frozen through KILL_APPLICATION_MSG, so</span></span><br><span class="line">            <span class="comment">// it doesn't hurt to use it again.)</span></span><br><span class="line">            forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid), <span class="keyword">false</span>,</span><br><span class="line">                    <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, UserHandle.getUserId(app.userId), <span class="string">"start failure"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">startProcessLocked</span><span class="params">(String hostingType, String hostingNameStr, String entryPoint,</span></span></span><br><span class="line"><span class="function"><span class="params">            ProcessRecord app, <span class="keyword">int</span> uid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">            String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> startTime)</span> </span>&#123;</span><br><span class="line">        app.pendingStart = <span class="keyword">true</span>;</span><br><span class="line">        app.killedByAm = <span class="keyword">false</span>;</span><br><span class="line">        app.removed = <span class="keyword">false</span>;</span><br><span class="line">        app.killed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> startSeq = app.startSeq = ++mProcStartSeqCounter;</span><br><span class="line">        app.setStartParams(uid, hostingType, hostingNameStr, seInfo, startTime);</span><br><span class="line">        <span class="comment">//如果进程启动为异步启动</span></span><br><span class="line">        <span class="keyword">if</span> (mConstants.FLAG_PROCESS_START_ASYNC) &#123;</span><br><span class="line">           ···</span><br><span class="line">           <span class="keyword">final</span> ProcessStartResult startResult = startProcess(app.hostingType, entryPoint,</span><br><span class="line">                            app, app.startUid, gids, runtimeFlags, mountExternal, app.seInfo,</span><br><span class="line">                            requiredAbi, instructionSet, invokeWith, app.startTime);</span><br><span class="line">                    <span class="keyword">synchronized</span> (ActivityManagerService.<span class="keyword">this</span>) &#123;</span><br><span class="line">                        handleProcessStartedLocked(app, startResult, startSeq);</span><br><span class="line">                    &#125;</span><br><span class="line">            ···</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          ···</span><br><span class="line">           <span class="keyword">final</span> ProcessStartResult startResult = startProcess(hostingType, entryPoint, app,</span><br><span class="line">                        uid, gids, runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                        invokeWith, startTime);</span><br><span class="line">                handleProcessStartedLocked(app, startResult.pid, startResult.usingWrapper,</span><br><span class="line">                        startSeq, <span class="keyword">false</span>);</span><br><span class="line">            ···</span><br><span class="line">            <span class="keyword">return</span> app.pid &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ProcessStartResult <span class="title">startProcess</span><span class="params">(String hostingType, String entryPoint,</span></span></span><br><span class="line"><span class="function"><span class="params">            ProcessRecord app, <span class="keyword">int</span> uid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">            String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> startTime)</span> </span>&#123;</span><br><span class="line">            ···</span><br><span class="line">            <span class="keyword">final</span> ProcessStartResult startResult;</span><br><span class="line">            <span class="comment">//如果是"webview_service"类型的话</span></span><br><span class="line">            <span class="comment">//调用startWebView方法</span></span><br><span class="line">            <span class="keyword">if</span> (hostingType.equals(<span class="string">"webview_service"</span>)) &#123;</span><br><span class="line">                startResult = startWebView(entryPoint,</span><br><span class="line">                        app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                        app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                        app.info.dataDir, <span class="keyword">null</span>,</span><br><span class="line">                        <span class="keyword">new</span> String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//调用Process#start方法</span></span><br><span class="line">                startResult = Process.start(entryPoint,</span><br><span class="line">                        app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                        app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                        app.info.dataDir, invokeWith,</span><br><span class="line">                        <span class="keyword">new</span> String[] &#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            checkTime(startTime, <span class="string">"startProcess: returned from zygote!"</span>);</span><br><span class="line">            <span class="keyword">return</span> startResult;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里出现了Process的start方法，那是不是说进程的创建就是它完成的呢，我们继续：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ProcessStartResult <span class="title">start</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String[] zygoteArgs)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//这里的zygoteProcess是一个ZygoteProcess对象</span></span><br><span class="line">       <span class="keyword">return</span> zygoteProcess.start(processClass, niceName, uid, gid, gids,</span><br><span class="line">                   runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                   abi, instructionSet, appDataDir, invokeWith, zygoteArgs);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ProcessStartResult <span class="title">startWebView</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String[] zygoteArgs)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> WebViewZygote.getProcess().start(processClass, niceName, uid, gid, gids,</span><br><span class="line">                   runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                   abi, instructionSet, appDataDir, invokeWith, zygoteArgs);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到两种方式都不是在这里创建进程的，而是分别交给了ZygoteProcess和WebViewZygote来完成。注释中我写到zygoteProcess是一个ZygoteProcess对象是从何而来呢，先来看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ZygoteProcess zygoteProcess =</span><br><span class="line">           <span class="keyword">new</span> ZygoteProcess(ZYGOTE_SOCKET, SECONDARY_ZYGOTE_SOCKET);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZygoteProcess</span><span class="params">(String primarySocket, String secondarySocket)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(<span class="keyword">new</span> LocalSocketAddress(primarySocket, LocalSocketAddress.Namespace.RESERVED),</span><br><span class="line">               <span class="keyword">new</span> LocalSocketAddress(secondarySocket, LocalSocketAddress.Namespace.RESERVED));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ZygoteProcess</span><span class="params">(LocalSocketAddress primarySocket, LocalSocketAddress secondarySocket)</span> </span>&#123;</span><br><span class="line">       mSocket = primarySocket;</span><br><span class="line">       mSecondarySocket = secondarySocket;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> LocalSocketAddress <span class="title">getPrimarySocketAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> mSocket;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>我们发现这里似乎用到了Socket的方式来实现跨进程通信，至于后面具体怎么实现，慢慢往后看。先来看看WebViewZygote.getProcess()方法做了什么，是不是拿到的也是一个ZygoteProcess对象呢：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ChildZygoteProcess sZygote;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZygoteProcess <span class="title">getProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sLock) &#123;</span><br><span class="line">            <span class="comment">//如果不为空 就直接返回这个sZygote</span></span><br><span class="line">            <span class="keyword">if</span> (sZygote != <span class="keyword">null</span>) <span class="keyword">return</span> sZygote;</span><br><span class="line">            <span class="comment">//不用想 这里肯定是创建一个ZygoteProcess </span></span><br><span class="line">           <span class="comment">//并赋值给sZygote  然后返回</span></span><br><span class="line">            connectToZygoteIfNeededLocked();</span><br><span class="line">            <span class="keyword">return</span> sZygote;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里的sZygote是一个ChildZygoteProcess对象，实际上我们的才想也并没有错误，因为这个ChildZygoteProcess是ZygoteProcess的子类，其构造方法就是调用的ZygoteProcess的构造方法。那么现在就要看看ZygoteProcess的start方法又是如何实现的了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Process.<span class="function">ProcessStartResult <span class="title">start</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 String[] zygoteArgs)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class="line">                   runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                   abi, instructionSet, appDataDir, invokeWith, <span class="keyword">false</span> <span class="comment">/* startChildZygote */</span>,</span><br><span class="line">                   zygoteArgs);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (ZygoteStartFailedEx ex) &#123;</span><br><span class="line">           Log.e(LOG_TAG,</span><br><span class="line">                   <span class="string">"Starting VM process through Zygote failed"</span>);</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                   <span class="string">"Starting VM process through Zygote failed"</span>, ex);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> Process.<span class="function">ProcessStartResult <span class="title">startViaZygote</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     <span class="keyword">final</span> <span class="keyword">int</span> uid, <span class="keyword">final</span> <span class="keyword">int</span> gid,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     <span class="keyword">final</span> <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     <span class="keyword">boolean</span> startChildZygote,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     String[] extraArgs)</span></span></span><br><span class="line"><span class="function">                                                     <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">       ArrayList&lt;String&gt; argsForZygote = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// --runtime-args, --setuid=, --setgid=,</span></span><br><span class="line">       <span class="comment">// and --setgroups= must go first</span></span><br><span class="line">       argsForZygote.add(<span class="string">"--runtime-args"</span>);</span><br><span class="line">       argsForZygote.add(<span class="string">"--setuid="</span> + uid);</span><br><span class="line">       argsForZygote.add(<span class="string">"--setgid="</span> + gid);</span><br><span class="line">       argsForZygote.add(<span class="string">"--runtime-flags="</span> + runtimeFlags);</span><br><span class="line">       <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) &#123;</span><br><span class="line">           argsForZygote.add(<span class="string">"--mount-external-default"</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_READ) &#123;</span><br><span class="line">           argsForZygote.add(<span class="string">"--mount-external-read"</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_WRITE) &#123;</span><br><span class="line">           argsForZygote.add(<span class="string">"--mount-external-write"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       argsForZygote.add(<span class="string">"--target-sdk-version="</span> + targetSdkVersion);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// --setgroups is a comma-separated list</span></span><br><span class="line">       <span class="keyword">if</span> (gids != <span class="keyword">null</span> &amp;&amp; gids.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">           sb.append(<span class="string">"--setgroups="</span>);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> sz = gids.length;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                   sb.append(<span class="string">','</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               sb.append(gids[i]);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           argsForZygote.add(sb.toString());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (niceName != <span class="keyword">null</span>) &#123;</span><br><span class="line">           argsForZygote.add(<span class="string">"--nice-name="</span> + niceName);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (seInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">           argsForZygote.add(<span class="string">"--seinfo="</span> + seInfo);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (instructionSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">           argsForZygote.add(<span class="string">"--instruction-set="</span> + instructionSet);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (appDataDir != <span class="keyword">null</span>) &#123;</span><br><span class="line">           argsForZygote.add(<span class="string">"--app-data-dir="</span> + appDataDir);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (invokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">           argsForZygote.add(<span class="string">"--invoke-with"</span>);</span><br><span class="line">           argsForZygote.add(invokeWith);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (startChildZygote) &#123;</span><br><span class="line">           argsForZygote.add(<span class="string">"--start-child-zygote"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       argsForZygote.add(processClass);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (extraArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (String arg : extraArgs) &#123;</span><br><span class="line">               argsForZygote.add(arg);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">//将大量的字符串添加到argsForZygote之后</span></span><br><span class="line">       <span class="comment">//将argsForZygote发送到zygote进程并获取结果</span></span><br><span class="line">       <span class="keyword">synchronized</span>(mLock) &#123;</span><br><span class="line">           <span class="keyword">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Process.<span class="function">ProcessStartResult <span class="title">zygoteSendArgsAndGetResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">           ZygoteState zygoteState, ArrayList&lt;String&gt; args)</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// Throw early if any of the arguments are malformed. This means we can</span></span><br><span class="line">           <span class="comment">// avoid writing a partial response to the zygote.</span></span><br><span class="line">           <span class="keyword">int</span> sz = args.size();</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (args.get(i).indexOf(<span class="string">'\n'</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"embedded newlines not allowed"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * See com.android.internal.os.SystemZygoteInit.readArgumentList()</span></span><br><span class="line"><span class="comment">            * Presently the wire format to the zygote process is:</span></span><br><span class="line"><span class="comment">            * a) a count of arguments (argc, in essence)</span></span><br><span class="line"><span class="comment">            * b) a number of newline-separated argument strings equal to count</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            * After the zygote process reads these it will write the pid of</span></span><br><span class="line"><span class="comment">            * the child or -1 on failure, followed by boolean to</span></span><br><span class="line"><span class="comment">            * indicate whether a wrapper process was used.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">//将应用进程的启动参数argsForZygote写入到ZygoteState中</span></span><br><span class="line">           <span class="keyword">final</span> BufferedWriter writer = zygoteState.writer;</span><br><span class="line">           <span class="keyword">final</span> DataInputStream inputStream = zygoteState.inputStream;</span><br><span class="line"></span><br><span class="line">           writer.write(Integer.toString(args.size()));</span><br><span class="line">           writer.newLine();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">               String arg = args.get(i);</span><br><span class="line">               writer.write(arg);</span><br><span class="line">               writer.newLine();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           writer.flush();</span><br><span class="line"></span><br><span class="line">           <span class="comment">//new了一个Process.ProcessStartResult对象，显然这个对象包装了进程启动的各种信息</span></span><br><span class="line">           <span class="comment">// Should there be a timeout on this?</span></span><br><span class="line">           Process.ProcessStartResult result = <span class="keyword">new</span> Process.ProcessStartResult();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Always read the entire result from the input stream to avoid leaving</span></span><br><span class="line">           <span class="comment">// bytes in the stream for future process starts to accidentally stumble</span></span><br><span class="line">           <span class="comment">// upon.</span></span><br><span class="line">           result.pid = inputStream.readInt();</span><br><span class="line">           result.usingWrapper = inputStream.readBoolean();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (result.pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"fork() failed"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">           zygoteState.close();</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(ex);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>因为Zygote所在进程与AMS所在进程不同，根据方法被调用时可以发现这个zygoteState是通过openZygoteSocketIfNeeded(abi)创建的，再看看这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ZygoteState <span class="title">openZygoteSocketIfNeeded</span><span class="params">(String abi)</span> <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">        Preconditions.checkState(Thread.holdsLock(mLock), <span class="string">"ZygoteProcess lock not held"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (primaryZygoteState == <span class="keyword">null</span> || primaryZygoteState.isClosed()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">//注释1</span></span><br><span class="line">                primaryZygoteState = ZygoteState.connect(mSocket);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"Error connecting to primary zygote"</span>, ioe);</span><br><span class="line">            &#125;</span><br><span class="line">            maybeSetApiBlacklistExemptions(primaryZygoteState, <span class="keyword">false</span>);</span><br><span class="line">            maybeSetHiddenApiAccessLogSampleRate(primaryZygoteState);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果与“zygote”的Socket连接返回的primaryZygoteState相匹配这直接返回该对象</span></span><br><span class="line">        <span class="keyword">if</span> (primaryZygoteState.matches(abi)) &#123;</span><br><span class="line">            <span class="keyword">return</span> primaryZygoteState;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注释2 如果不相匹配 则进行第二次</span></span><br><span class="line">        <span class="comment">// The primary zygote didn't match. Try the secondary.</span></span><br><span class="line">        <span class="keyword">if</span> (secondaryZygoteState == <span class="keyword">null</span> || secondaryZygoteState.isClosed()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                secondaryZygoteState = ZygoteState.connect(mSecondarySocket);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"Error connecting to secondary zygote"</span>, ioe);</span><br><span class="line">            &#125;</span><br><span class="line">            maybeSetApiBlacklistExemptions(secondaryZygoteState, <span class="keyword">false</span>);</span><br><span class="line">            maybeSetHiddenApiAccessLogSampleRate(secondaryZygoteState);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (secondaryZygoteState.matches(abi)) &#123;</span><br><span class="line">            <span class="keyword">return</span> secondaryZygoteState;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"Unsupported zygote ABI: "</span> + abi);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>先看注释1处，这里调用ZygoteState的connect函数与mSocket的Socket建立连接，还记得之前在ZygoteProcess构造方法里传入的ZYGOTE_SOCKET和SECONDARY_ZYGOTE_SOCKET，它们的值分别对应的是”zygote”和”zygote_secondary”，这是因为Zygote进程启动过程时，在Zygote的main函数中会创建name为“zygote”的Server端Socket，如果连接name为“zygote”的Socket返回的primaryZygoteState与当前的abi不匹配，则会在注释2处连接name为“zygote_secondary”的Socket。这两个Socket区别就是：name为”zygote”的Socket是运行在64位Zygote进程中的，而name为“zygote_secondary”的Socket则运行在32位Zygote进程中。既然应用程序进程是通过Zygote进程fock产生的，当要连接Zygote中的Socket时，也需要保证位数的一致。</p>
<p>Socket进行连接成功并匹配abi后会返回ZygoteState类型对象，我们在分析zygoteSendArgsAndGetResult函数中讲过，会将应用进程的启动参数argsForZygote写入到ZygoteState中，这样Zygote进程就会收到一个创建新的应用程序进程的请求，我们回到ZygoteInit的main函数，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">    ZygoteServer zygoteServer = <span class="keyword">new</span> ZygoteServer();</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line">        <span class="keyword">final</span> Runnable caller;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">         ...   </span><br><span class="line">            <span class="comment">//注册Zygote用的Socket</span></span><br><span class="line">           zygoteServer.registerServerSocketFromEnv(socketName);<span class="comment">//注释1</span></span><br><span class="line">           ...</span><br><span class="line">           <span class="comment">//预加载类和资源</span></span><br><span class="line">           preload(bootTimingsTraceLog);<span class="comment">//注释2</span></span><br><span class="line">           ...</span><br><span class="line">            <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">                Runnable r = forkSystemServer(abiList, socketName, zygoteServer);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// &#123;@code r == null&#125; in the parent (zygote) process, and &#123;@code r != null&#125; in the</span></span><br><span class="line">                <span class="comment">// child (system_server) process.</span></span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    r.run();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Log.i(TAG, <span class="string">"Accepting command socket connections"</span>);</span><br><span class="line">            <span class="comment">//等待客户端请求</span></span><br><span class="line">            caller = zygoteServer.runSelectLoop(abiList);<span class="comment">//注释4</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"System zygote died with exception"</span>, ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            zygoteServer.closeServerSocket();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We're in the child process and have exited the select loop. Proceed to execute the</span></span><br><span class="line">        <span class="comment">// command.</span></span><br><span class="line">        <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">            caller.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注释1处通过registerZygoteSocket函数来创建一个Server端的Socket，这个name为”zygote”的Socket用来等待ActivityManagerService来请求Zygote来创建新的应用程序进程</p>
</li>
<li><p>注释2处用来预加载类和资源。</p>
</li>
<li><p>注释3处用来启动SystemServer进程，这样系统的关键服务也会由SystemServer进程启动起来。</p>
</li>
<li><p>注释4处调用runSelectLoop函数来等待ActivityManagerService的请求,我们就来查看runSelectLoop:</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Runnable <span class="title">runSelectLoop</span><span class="params">(String abiList)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;FileDescriptor&gt; fds = <span class="keyword">new</span> ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">        ArrayList&lt;ZygoteConnection&gt; peers = <span class="keyword">new</span> ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line"></span><br><span class="line">        fds.add(mServerSocket.getFileDescriptor());</span><br><span class="line">        peers.add(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            StructPollfd[] pollFds = <span class="keyword">new</span> StructPollfd[fds.size()];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pollFds.length; ++i) &#123;</span><br><span class="line">                pollFds[i] = <span class="keyword">new</span> StructPollfd();</span><br><span class="line">                pollFds[i].fd = fds.get(i);</span><br><span class="line">                pollFds[i].events = (<span class="keyword">short</span>) POLLIN;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Os.poll(pollFds, -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"poll failed"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = pollFds.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((pollFds[i].revents &amp; POLLIN) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    ZygoteConnection newPeer = acceptCommandPeer(abiList);</span><br><span class="line">                    peers.add(newPeer);</span><br><span class="line">                    fds.add(newPeer.getFileDesciptor());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        ZygoteConnection connection = peers.get(i);</span><br><span class="line">                        <span class="keyword">final</span> Runnable command = connection.processOneCommand(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (mIsForkChild) &#123;</span><br><span class="line">                            <span class="comment">// We're in the child. We should always have a command to run at this</span></span><br><span class="line">                            <span class="comment">// stage if processOneCommand hasn't called "exec".</span></span><br><span class="line">                            <span class="keyword">if</span> (command == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"command == null"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">return</span> command;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// We're in the server - we should never have any commands to run.</span></span><br><span class="line">                            <span class="keyword">if</span> (command != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"command != null"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// We don't know whether the remote side of the socket was closed or</span></span><br><span class="line">                            <span class="comment">// not until we attempt to read from it from processOneCommand. </span></span><br><span class="line">                            <span class="comment">// This shows up as</span></span><br><span class="line">                            <span class="comment">// a regular POLLIN event in our regular processing loop.</span></span><br><span class="line">                            <span class="keyword">if</span> (connection.isClosedByPeer()) &#123;</span><br><span class="line">                                connection.closeSocket();</span><br><span class="line">                                peers.remove(i);</span><br><span class="line">                                fds.remove(i);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!mIsForkChild) &#123;</span><br><span class="line">                            <span class="comment">// We're in the server so any exception here is one that has taken place</span></span><br><span class="line">                            <span class="comment">// pre-fork while processing commands or reading / writing from the</span></span><br><span class="line">                            <span class="comment">// control socket. Make a loud noise about any such exceptions so that</span></span><br><span class="line">                            <span class="comment">// we know exactly what failed and why.</span></span><br><span class="line"></span><br><span class="line">                            Slog.e(TAG, <span class="string">"Exception executing zygote command: "</span>, e);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// Make sure the socket is closed so that the other end knows immediately</span></span><br><span class="line">                            <span class="comment">// that something has gone wrong and doesn't time out waiting for a</span></span><br><span class="line">                            <span class="comment">// response.</span></span><br><span class="line">                            ZygoteConnection conn = peers.remove(i);</span><br><span class="line">                            conn.closeSocket();</span><br><span class="line"></span><br><span class="line">                            fds.remove(i);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// We're in the child so any exception caught here has happened post</span></span><br><span class="line">                            <span class="comment">// fork and before we execute ActivityThread.main (or any other main()</span></span><br><span class="line">                            <span class="comment">// method). Log the details of the exception and bring down the process.</span></span><br><span class="line">                            Log.e(TAG, <span class="string">"Caught post-fork exception in child process."</span>, e);</span><br><span class="line">                            <span class="keyword">throw</span> e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// Reset the child flag, in the event that the child process is a child-</span></span><br><span class="line">                        <span class="comment">// zygote. The flag will not be consulted this loop pass after the Runnable</span></span><br><span class="line">                        <span class="comment">// is returned.</span></span><br><span class="line">                        mIsForkChild = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里要返回的Runnable对象又到了ZygoteConnection的processOneCommand方法里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Runnable <span class="title">processOneCommand</span><span class="params">(ZygoteServer zygoteServer)</span> </span>&#123;</span><br><span class="line">        String args[];</span><br><span class="line">        Arguments parsedArgs = <span class="keyword">null</span>;</span><br><span class="line">        FileDescriptor[] descriptors;</span><br><span class="line">        ···</span><br><span class="line">        <span class="keyword">int</span> pid = -<span class="number">1</span>;</span><br><span class="line">        FileDescriptor childPipeFd = <span class="keyword">null</span>;</span><br><span class="line">        FileDescriptor serverPipeFd = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        parsedArgs = <span class="keyword">new</span> Arguments(args);</span><br><span class="line"></span><br><span class="line">        ···</span><br><span class="line">        applyUidSecurityPolicy(parsedArgs, peer);</span><br><span class="line">        applyInvokeWithSecurityPolicy(parsedArgs, peer);</span><br><span class="line"></span><br><span class="line">        applyDebuggerSystemProperty(parsedArgs);</span><br><span class="line">        applyInvokeWithSystemProperty(parsedArgs);</span><br><span class="line">        ···</span><br><span class="line">        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</span><br><span class="line">                parsedArgs.runtimeFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</span><br><span class="line">                parsedArgs.niceName, fdsToClose, fdsToIgnore, parsedArgs.startChildZygote,</span><br><span class="line">                parsedArgs.instructionSet, parsedArgs.appDataDir);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// in child</span></span><br><span class="line">                zygoteServer.setForkChild();</span><br><span class="line"></span><br><span class="line">                zygoteServer.closeServerSocket();</span><br><span class="line">                IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">                serverPipeFd = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> handleChildProc(parsedArgs, descriptors, childPipeFd,</span><br><span class="line">                        parsedArgs.startChildZygote);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// In the parent. A pid &lt; 0 indicates a failure and will be handled in</span></span><br><span class="line">                <span class="comment">// handleParentProc.</span></span><br><span class="line">                IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">                childPipeFd = <span class="keyword">null</span>;</span><br><span class="line">                handleParentProc(pid, descriptors, serverPipeFd);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">            IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>再看handleChildProc方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">handleChildProc</span><span class="params">(Arguments parsedArgs, FileDescriptor[] descriptors,</span></span></span><br><span class="line"><span class="function"><span class="params">        FileDescriptor pipeFd, <span class="keyword">boolean</span> isZygote)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * By the time we get here, the native code has closed the two actual Zygote</span></span><br><span class="line"><span class="comment">     * socket connections, and substituted /dev/null in their place.  The LocalSocket</span></span><br><span class="line"><span class="comment">     * objects still need to be closed properly.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ···</span><br><span class="line">    closeSocket();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.niceName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Process.setArgV0(parsedArgs.niceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// End of the postFork event.</span></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.invokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">        WrapperInit.execApplication(parsedArgs.invokeWith,</span><br><span class="line">                parsedArgs.niceName, parsedArgs.targetSdkVersion,</span><br><span class="line">                VMRuntime.getCurrentInstructionSet(),</span><br><span class="line">                pipeFd, parsedArgs.remainingArgs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Should not get here.</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"WrapperInit.execApplication unexpectedly returned"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//传进来的参数，上文传进来的是parsedArgs.startChildZygote</span></span><br><span class="line">      <span class="comment">//根据命名显然是是否开始子进程的意思，所以为true</span></span><br><span class="line">        <span class="keyword">if</span> (!isZygote) &#123;</span><br><span class="line">            <span class="keyword">return</span> ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs,</span><br><span class="line">                    <span class="keyword">null</span> <span class="comment">/* classLoader */</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ZygoteInit.childZygoteInit(parsedArgs.targetSdkVersion,</span><br><span class="line">                    parsedArgs.remainingArgs, <span class="keyword">null</span> <span class="comment">/* classLoader */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看ZygoteInit.childZygoteInit方法，这里传进去了目标SDK版本和相关参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> Runnable <span class="title">childZygoteInit</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        RuntimeInit.Arguments args = <span class="keyword">new</span> RuntimeInit.Arguments(argv);</span><br><span class="line">        <span class="keyword">return</span> RuntimeInit.findStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法就比较简单了，直接传到了RuntimeInit.findStaticMain方法里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Runnable <span class="title">findStaticMain</span><span class="params">(String className, String[] argv,</span></span></span><br><span class="line"><span class="function"><span class="params">            ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; cl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cl = Class.forName(className, <span class="keyword">true</span>, classLoader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Missing class when invoking static main "</span> + className,</span><br><span class="line">                    ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Method m;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m = cl.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> Class[] &#123; String[].class &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Missing static main on "</span> + className, ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Problem getting static main on "</span> + className, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> modifiers = m.getModifiers();</span><br><span class="line">        <span class="keyword">if</span> (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Main method is not public and static on "</span> + className);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This throw gets caught in ZygoteInit.main(), which responds</span></span><br><span class="line"><span class="comment">         * by invoking the exception's run() method. This arrangement</span></span><br><span class="line"><span class="comment">         * clears up all the stack frames that were required in setting</span></span><br><span class="line"><span class="comment">         * up the process.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MethodAndArgsCaller(m, argv);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最终这里返回了一个MethodAndArgsCaller对象，根据方法的返回值可以很容易知道这是一个Runnable对象，其实它是RuntimeInit的内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAndArgsCaller</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** method to call */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Method mMethod;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** argument array */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String[] mArgs;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MethodAndArgsCaller</span><span class="params">(Method method, String[] args)</span> </span>&#123;</span><br><span class="line">            mMethod = method;</span><br><span class="line">            mArgs = args;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; mArgs &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">                Throwable cause = ex.getCause();</span><br><span class="line">                <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> (RuntimeException) cause;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> (Error) cause;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>所以看到这里就知道上文caller就是这里的MethodAndArgsCaller对象，调用run方法执行的就是通过反射执行传进来的方法。这个方法在findStaticMain方法里知道了是main方法，那么是哪一个类呢，是ActivityThread类，这是在findStaticMain方法里通过反射找到的。</p>
<h2 id="ActivityThread-main——App-onCreate"><a href="#ActivityThread-main——App-onCreate" class="headerlink" title="ActivityThread#main——App#onCreate"></a>ActivityThread#main——App#onCreate</h2><p>现在程序就执行到了ActivityThread.main方法了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"ActivityThreadMain"</span>);</span><br><span class="line">      ···</span><br><span class="line">      Looper.prepareMainLooper();</span><br><span class="line">      ···</span><br><span class="line">      ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">      thread.attach(<span class="keyword">false</span>, startSeq);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">          sMainThreadHandler = thread.getHandler();</span><br><span class="line">      &#125;</span><br><span class="line">      ···</span><br><span class="line">      Looper.loop();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里主要的三件事:</p>
<ul>
<li>调用Looper.prepareMainLooper 创建并赋值（这个looper的MessageQueue不能quit）静态变量 sMainLooper ，这样应用可以在任何地方拿到主线程的Looper对象</li>
<li>创建ActivityThread实例，并调用attach，这两步很关键，首先，ActivityThread对象创建时，会创建ResourcesManager的单例对象。在thread.attach(false, startSeq)中还会创建 IActivityManager 对象即AMS，并为app绑定一个Application对象：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">        sCurrentActivityThread = <span class="keyword">this</span>;</span><br><span class="line">        mSystemThread = system;</span><br><span class="line">        <span class="keyword">if</span> (!system) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">final</span> IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//这里传入的mAppThread是一个IApplicationThread对象</span></span><br><span class="line">            mgr.attachApplication(mAppThread, startSeq);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="comment">//添加一个GC回收的观察对象，当内存占用3/4时就会释放一些资源</span></span><br><span class="line">        <span class="comment">// Watch for getting close to heap limit.</span></span><br><span class="line">        BinderInternal.addGcWatcher(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!mSomeActivitiesChanged) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Runtime runtime = Runtime.getRuntime();</span><br><span class="line">                <span class="keyword">long</span> dalvikMax = runtime.maxMemory();</span><br><span class="line">                <span class="keyword">long</span> dalvikUsed = runtime.totalMemory() - runtime.freeMemory();</span><br><span class="line">                <span class="keyword">if</span> (dalvikUsed &gt; ((<span class="number">3</span>*dalvikMax)/<span class="number">4</span>)) &#123;</span><br><span class="line">                    mSomeActivitiesChanged = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        mgr.releaseSomeActivities(mAppThread);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ViewRootImpl.addConfigCallback(configChangedCallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面已经知道了这里的IActivityManager就是一个ActivityManagerService对象，看它的attachApplication方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attachApplication</span><span class="params">(IApplicationThread thread, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> callingPid = Binder.getCallingPid();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">            attachApplicationLocked(thread, callingPid, callingUid, startSeq);</span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> pid, <span class="keyword">int</span> callingUid, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// See if the top visible activity is waiting to run in this process...</span></span><br><span class="line">    <span class="keyword">if</span> (normalMode) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mStackSupervisor.attachApplicationLocked(app)) &#123;</span><br><span class="line">                didSomething = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Slog.wtf(TAG, <span class="string">"Exception thrown launching activities in "</span> + app, e);</span><br><span class="line">            badApp = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里又跳转到了ActivityStackSupervisor的attachApplicationLocked方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(ProcessRecord app)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String processName = app.processName;</span><br><span class="line">    <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> displayNdx = mActivityDisplays.size() - <span class="number">1</span>; displayNdx &gt;= <span class="number">0</span>; --displayNdx) &#123;</span><br><span class="line">        <span class="keyword">final</span> ActivityDisplay display = mActivityDisplays.valueAt(displayNdx);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> stackNdx = display.getChildCount() - <span class="number">1</span>; stackNdx &gt;= <span class="number">0</span>; --stackNdx) &#123;</span><br><span class="line">            <span class="keyword">final</span> ActivityStack stack = display.getChildAt(stackNdx);</span><br><span class="line">            <span class="keyword">if</span> (!isFocusedStack(stack)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.getAllRunningVisibleActivitiesLocked(mTmpActivityList);</span><br><span class="line">            <span class="keyword">final</span> ActivityRecord top = stack.topRunningActivityLocked();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> size = mTmpActivityList.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> ActivityRecord activity = mTmpActivityList.get(i);</span><br><span class="line">                <span class="comment">//如果前台栈顶Activity对应的进程信息，与新启动的进程相互吻合时，该进程就需要启动该Activity</span></span><br><span class="line">                <span class="keyword">if</span> (activity.app == <span class="keyword">null</span> &amp;&amp; app.uid == activity.info.applicationInfo.uid</span><br><span class="line">                        &amp;&amp; processName.equals(activity.processName)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (realStartActivityLocked(activity, app,</span><br><span class="line">                                top == activity <span class="comment">/* andResume */</span>, <span class="keyword">true</span> <span class="comment">/* checkConfig */</span>)) &#123;</span><br><span class="line">                            didSomething = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Exception in new application when starting activity "</span></span><br><span class="line">                                + top.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">                        <span class="keyword">throw</span> e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!didSomething) &#123;</span><br><span class="line">        ensureActivitiesVisibleLocked(<span class="keyword">null</span>, <span class="number">0</span>, !PRESERVE_WINDOWS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里出现了一个之前提到但没有看过的方法，realStartActivityLocked方法，之前分析过程中说过如果应用进程已经启动的情况下去启动Activity所调用的方法，那么现在来看看:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">realStartActivityLocked</span><span class="params">(ActivityRecord r, ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">            ···</span><br><span class="line">            <span class="keyword">final</span> TaskRecord task = r.getTask();</span><br><span class="line">            <span class="keyword">final</span> ActivityStack stack = task.getStack();</span><br><span class="line">             ···</span><br><span class="line">            <span class="comment">// Create activity launch transaction.</span></span><br><span class="line">            <span class="keyword">final</span> ClientTransaction clientTransaction = ClientTransaction.obtain(app.thread,</span><br><span class="line">                    r.appToken);</span><br><span class="line">            clientTransaction.addCallback(LaunchActivityItem.obtain(<span class="keyword">new</span> Intent(r.intent),</span><br><span class="line">                    System.identityHashCode(r), r.info,</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> Have this take the merged configuration instead of separate global</span></span><br><span class="line">                    <span class="comment">// and override configs.</span></span><br><span class="line">                    mergedConfiguration.getGlobalConfiguration(),</span><br><span class="line">                    mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">                    r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,</span><br><span class="line">                    r.persistentState, results, newIntents, mService.isNextTransitionForward(),</span><br><span class="line">                    profilerInfo));</span><br><span class="line">            <span class="comment">// Set desired final state.</span></span><br><span class="line">            <span class="keyword">final</span> ActivityLifecycleItem lifecycleItem;</span><br><span class="line">            <span class="keyword">if</span> (andResume) &#123;</span><br><span class="line">                lifecycleItem = ResumeActivityItem.obtain(mService.isNextTransitionForward());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lifecycleItem = PauseActivityItem.obtain();</span><br><span class="line">            &#125;</span><br><span class="line">            clientTransaction.setLifecycleStateRequest(lifecycleItem);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Schedule transaction.</span></span><br><span class="line">            mService.getLifecycleManager().scheduleTransaction(clientTransaction);</span><br><span class="line">            ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们看到最后一行，mService.getLifecycleManager:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ClientLifecycleManager <span class="title">getLifecycleManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mLifecycleManager;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>再到ClientLifecycleManager 里看scheduleTransaction方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> IApplicationThread client = transaction.getClient();</span><br><span class="line">        transaction.schedule();</span><br><span class="line">        <span class="keyword">if</span> (!(client <span class="keyword">instanceof</span> Binder)) &#123;</span><br><span class="line">            <span class="comment">// If client is not an instance of Binder - it's a remote call and at this point it is</span></span><br><span class="line">            <span class="comment">// safe to recycle the object. All objects used for local calls will be recycled after</span></span><br><span class="line">            <span class="comment">// the transaction is executed on client in ActivityThread.</span></span><br><span class="line">            transaction.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span> IApplicationThread mClient;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        mClient.scheduleTransaction(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>那么这里的mClint是什么呢，他其实就是上面调用clientTransaction.obtain方法时传入的IApplicationThread实例,是一个ApplicationThread对象，那么现在再看scheduleTransaction方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationThread</span> <span class="keyword">extends</span> <span class="title">IApplicationThread</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            ActivityThread.<span class="keyword">this</span>.scheduleTransaction(transaction);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于继承自IApplicationThread.Stub，所以这里的Application就是一个Binder，然后在scheduleTransaction调用了ActivityThread的scheduleTransaction方法,这就又回到了app，但是由于ActivityThread并没有重写该方法，所以调用的实际上是它的父类ClientTransactionHandler的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">       transaction.preExecute(<span class="keyword">this</span>);</span><br><span class="line">       <span class="comment">// 抽象方法 具体实现由ActivityThread实现</span></span><br><span class="line">       sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);</span><br><span class="line">   &#125;</span><br><span class="line">     <span class="comment">//ActivityThread</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj)</span> </span>&#123;</span><br><span class="line">       sendMessage(what, obj, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span> </span>&#123;</span><br><span class="line">        sendMessage(what, obj, arg1, arg2, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        ···</span><br><span class="line">        Message msg = Message.obtain();</span><br><span class="line">        msg.what = what;</span><br><span class="line">        msg.obj = obj;</span><br><span class="line">        msg.arg1 = arg1;</span><br><span class="line">        msg.arg2 = arg2;</span><br><span class="line">        <span class="keyword">if</span> (async) &#123;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//mH是H对象，也就是一个handler</span></span><br><span class="line">        mH.sendMessage(msg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>H继承自Handler，是ActivityThread的内部类，再看H的sendMessage方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">switch</span>（msg.what）&#123;</span><br><span class="line">        <span class="keyword">case</span> EXECUTE_TRANSACTION:</span><br><span class="line">                    <span class="keyword">final</span> ClientTransaction transaction = (ClientTransaction) msg.obj;</span><br><span class="line">                    mTransactionExecutor.execute(transaction);</span><br><span class="line">                    <span class="keyword">if</span> (isSystem()) &#123;</span><br><span class="line">                        <span class="comment">// Client transactions inside system process are recycled on the client side</span></span><br><span class="line">                        <span class="comment">// instead of ClientLifecycleManager to avoid being cleared before this</span></span><br><span class="line">                        <span class="comment">// message is handled.</span></span><br><span class="line">                        transaction.recycle();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// TODO(lifecycler): Recycle locally scheduled transactions.</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为节省篇幅这里只截取了源码中的EXECUTE_TRANSACTION一个消息，实际上源代码里还有很多，比如BIND_SERVICE，DISPATCH_PACKAGE_BROADCAST；可以看出四大组件的生命周期回调入口都在这里，具体就不在谈了。又看TransactionExecutor的execute方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> IBinder token = transaction.getActivityToken();</span><br><span class="line">        <span class="comment">//执行Callbacks，然后改变Activity当前的生命周期状态</span></span><br><span class="line">        <span class="comment">//显然app启动时还没有activity 则执行下一步</span></span><br><span class="line">        executeCallbacks(transaction);</span><br><span class="line"></span><br><span class="line">        executeLifecycleState(transaction);</span><br><span class="line">        mPendingActions.clear();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeLifecycleState</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest();</span><br><span class="line">        <span class="keyword">if</span> (lifecycleItem == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No lifecycle request, return early.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log(<span class="string">"Resolving lifecycle state: "</span> + lifecycleItem);</span><br><span class="line">        <span class="comment">// 创建ActivityClientRecord记录Activity，App进程的ActivityClientRecord和AMS中的ActivityRecord是一一对应的</span></span><br><span class="line">        <span class="comment">//他们之间通过token关联</span></span><br><span class="line">        <span class="keyword">final</span> IBinder token = transaction.getActivityToken();</span><br><span class="line">        <span class="keyword">final</span> ActivityClientRecord r = mTransactionHandler.getActivityClient(token);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Ignore requests for non-existent client records for now.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// // lifecycleItem.getTargetState()返回的是ON_RESUME</span></span><br><span class="line">        <span class="comment">// Cycle to the state right before the final requested state.</span></span><br><span class="line">        cycleToPath(r, lifecycleItem.getTargetState(), <span class="keyword">true</span> <span class="comment">/* excludeLastState */</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Execute the final transition with proper parameters.</span></span><br><span class="line">        lifecycleItem.execute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">        lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在executeLifecycleState方法里面，会调用TransactionExecutor的cycleToPath函数执行当前Activity的生命周期，第二个参数lifecycleItem.getTargetState确定了我们将要执行哪些声明周期函数，由于我们在realStartActivity函数中创建的是ResumeActivityItem对象，所以这里调用的是ResumeActivityItem的getTargetState函数:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTargetState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ON_RESUME;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只是单纯的返回了ON_RESUME，ON_RESUME保存在他的父类ActivityLifecycleItem中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNDEFINED = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRE_ON_CREATE = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ON_CREATE = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ON_START = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ON_RESUME = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ON_PAUSE = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ON_STOP = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ON_DESTROY = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ON_RESTART = <span class="number">7</span>;</span><br></pre></td></tr></table></figure>

<p>下面我们来看TransactionExecutor的cycleToPath函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cycleToPath</span><span class="params">(ActivityClientRecord r, <span class="keyword">int</span> finish,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> excludeLastState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前生命周期的状态</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> start = r.getLifecycleState();</span><br><span class="line">    log(<span class="string">"Cycle from: "</span> + start + <span class="string">" to: "</span> + finish + <span class="string">" excludeLastState:"</span> + excludeLastState);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> IntArray path = mHelper.getLifecyclePath(start, finish, excludeLastState);</span><br><span class="line">    performLifecycleSequence(r, path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该函数中创建了一个IntArray path，该path确定了我们将要执行哪些生命周期函数，之后调用了performLifecycleSequence函数:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performLifecycleSequence</span><span class="params">(ActivityClientRecord r, IntArray path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = path.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, state; i &lt; size; i++) &#123;</span><br><span class="line">        state = path.get(i);</span><br><span class="line">        log(<span class="string">"Transitioning to state: "</span> + state);</span><br><span class="line">        <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">            <span class="keyword">case</span> ON_CREATE:</span><br><span class="line">                mTransactionHandler.handleLaunchActivity(r, mPendingActions,</span><br><span class="line">                        <span class="keyword">null</span> <span class="comment">/* customIntent */</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ON_START:</span><br><span class="line">                mTransactionHandler.handleStartActivity(r, mPendingActions);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ON_RESUME:</span><br><span class="line">                mTransactionHandler.handleResumeActivity(r.token, <span class="keyword">false</span> <span class="comment">/* finalStateRequest */</span>,</span><br><span class="line">                        r.isForward, <span class="string">"LIFECYCLER_RESUME_ACTIVITY"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ON_PAUSE:</span><br><span class="line">                mTransactionHandler.handlePauseActivity(r.token, <span class="keyword">false</span> <span class="comment">/* finished */</span>,</span><br><span class="line">                        <span class="keyword">false</span> <span class="comment">/* userLeaving */</span>, <span class="number">0</span> <span class="comment">/* configChanges */</span>, mPendingActions,</span><br><span class="line">                        <span class="string">"LIFECYCLER_PAUSE_ACTIVITY"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ON_STOP:</span><br><span class="line">                mTransactionHandler.handleStopActivity(r.token, <span class="keyword">false</span> <span class="comment">/* show */</span>,</span><br><span class="line">                        <span class="number">0</span> <span class="comment">/* configChanges */</span>, mPendingActions, <span class="keyword">false</span> <span class="comment">/* finalStateRequest */</span>,</span><br><span class="line">                        <span class="string">"LIFECYCLER_STOP_ACTIVITY"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ON_DESTROY:</span><br><span class="line">                mTransactionHandler.handleDestroyActivity(r.token, <span class="keyword">false</span> <span class="comment">/* finishing */</span>,</span><br><span class="line">                        <span class="number">0</span> <span class="comment">/* configChanges */</span>, <span class="keyword">false</span> <span class="comment">/* getNonConfigInstance */</span>,</span><br><span class="line">                        <span class="string">"performLifecycleSequence. cycling to:"</span> + path.get(size - <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ON_RESTART:</span><br><span class="line">                mTransactionHandler.performRestartActivity(r.token, <span class="keyword">false</span> <span class="comment">/* start */</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unexpected lifecycle state: "</span> + state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>performLifecycleSequence会根据path执行Activity相应的生命周期函数。整个流程还是比较简单的，由于是Android9新增的机制，所以得着重看一看。由于是app的启动所以activity还没有创建，所以ActivityThread的handleLaunchActivity会最先被调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Activity <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingTransactionActions pendingActions, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If we are getting ready to gc after going to the background, well</span></span><br><span class="line">    <span class="comment">// we are back active so skip it.</span></span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line">    mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 性能相关</span></span><br><span class="line">    <span class="keyword">if</span> (r.profilerInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mProfiler.setProfiler(r.profilerInfo);</span><br><span class="line">        mProfiler.startProfiling();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure we are running with the most recent config.</span></span><br><span class="line">    handleConfigurationChanged(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (localLOGV) Slog.v(</span><br><span class="line">        TAG, <span class="string">"Handling launch of "</span> + r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize before creating the activity</span></span><br><span class="line">    <span class="keyword">if</span> (!ThreadedRenderer.sRendererDisabled) &#123;</span><br><span class="line">        GraphicsEnvironment.earlyInitEGL();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// initialize函数主要是在WindowManagerGlobal中获取WindowManagerService的代理</span></span><br><span class="line">    WindowManagerGlobal.initialize();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configuration相关</span></span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.createdConfig = <span class="keyword">new</span> Configuration(mConfiguration);</span><br><span class="line">        reportSizeConfigurations(r);</span><br><span class="line">        <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; pendingActions != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pendingActions.setOldState(r.state);</span><br><span class="line">            pendingActions.setRestoreInstanceState(<span class="keyword">true</span>);</span><br><span class="line">            pendingActions.setCallOnPostCreate(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If there was an error, for any reason, tell the activity manager to stop us.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ActivityManager.getService()</span><br><span class="line">                    .finishActivity(r.token, Activity.RESULT_CANCELED, <span class="keyword">null</span>,</span><br><span class="line">                            Activity.DONT_FINISH_TASK_WITH_ACTIVITY);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>handleLaunchActivity函数会调用performLaunchActivity返回一个Activity对象，接下来我们看performLaunchActivity函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取ActivityInfo</span></span><br><span class="line">    ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">    <span class="keyword">if</span> (r.packageInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ComponentName component = r.intent.getComponent();</span><br><span class="line">    <span class="keyword">if</span> (component == <span class="keyword">null</span>) &#123;</span><br><span class="line">        component = r.intent.resolveActivity(</span><br><span class="line">            mInitialApplication.getPackageManager());</span><br><span class="line">        r.intent.setComponent(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.activityInfo.targetActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        component = <span class="keyword">new</span> ComponentName(r.activityInfo.packageName,</span><br><span class="line">                r.activityInfo.targetActivity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建ContextImpl</span></span><br><span class="line">    ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用反射创建Activity</span></span><br><span class="line">    Activity activity = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line">        StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">        r.intent.setExtrasClassLoader(cl);</span><br><span class="line">        r.intent.prepareToEnterProcess();</span><br><span class="line">        <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.state.setClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Unable to instantiate activity "</span> + component</span><br><span class="line">                + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于在handleBindApplication函数中已经创建了Application，所以在LoadedApk类内mApplication不为空，此处直接返回handleBindApplication函数创建的Application对象</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Performing launch of "</span> + r);</span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(</span><br><span class="line">                TAG, r + <span class="string">": app="</span> + app</span><br><span class="line">                + <span class="string">", appName="</span> + app.getPackageName()</span><br><span class="line">                + <span class="string">", pkg="</span> + r.packageInfo.getPackageName()</span><br><span class="line">                + <span class="string">", comp="</span> + r.intent.getComponent().toShortString()</span><br><span class="line">                + <span class="string">", dir="</span> + r.packageInfo.getAppDir());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">            Configuration config = <span class="keyword">new</span> Configuration(mCompatConfiguration);</span><br><span class="line">            <span class="keyword">if</span> (r.overrideConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                config.updateFrom(r.overrideConfig);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_CONFIGURATION) Slog.v(TAG, <span class="string">"Launching activity "</span></span><br><span class="line">                    + r.activityInfo.name + <span class="string">" with config "</span> + config);</span><br><span class="line">            Window window = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (r.mPendingRemoveWindow != <span class="keyword">null</span> &amp;&amp; r.mPreserveWindow) &#123;</span><br><span class="line">                window = r.mPendingRemoveWindow;</span><br><span class="line">                r.mPendingRemoveWindow = <span class="keyword">null</span>;</span><br><span class="line">                r.mPendingRemoveWindowManager = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            appContext.setOuterContext(activity);</span><br><span class="line">            <span class="comment">// 调用activity的attach方法</span></span><br><span class="line">            activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                    r.referrer, r.voiceInteractor, window, r.configCallback);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (customIntent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                activity.mIntent = customIntent;</span><br><span class="line">            &#125;</span><br><span class="line">            r.lastNonConfigurationInstances = <span class="keyword">null</span>;</span><br><span class="line">            checkAndBlockForNetworkAccess();</span><br><span class="line">            activity.mStartedActivity = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> theme = r.activityInfo.getThemeResource();</span><br><span class="line">            <span class="keyword">if</span> (theme != <span class="number">0</span>) &#123;</span><br><span class="line">                activity.setTheme(theme);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 调用activity的OnCreate</span></span><br><span class="line">            <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!activity.mCalled) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                    <span class="string">"Activity "</span> + r.intent.getComponent().toShortString() +</span><br><span class="line">                    <span class="string">" did not call through to super.onCreate()"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            r.activity = activity;</span><br><span class="line">        &#125;</span><br><span class="line">        r.setState(ON_CREATE);</span><br><span class="line"></span><br><span class="line">        mActivities.put(r.token, r);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Unable to start activity "</span> + component</span><br><span class="line">                + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数performLaunchActivity首先利用反射机制创建了Activity对象，然后调用Activity的attach函数初始化新建的Activity，最后调用activity的onCreat函数。我们先看一下Activity.attach函数内部都做了什么。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span></span><br><span class="line"><span class="function"><span class="params">        Instrumentation instr, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">        Application application, Intent intent, ActivityInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        CharSequence title, Activity parent, String id,</span></span></span><br><span class="line"><span class="function"><span class="params">        NonConfigurationInstances lastNonConfigurationInstances,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        Window window, ActivityConfigCallback activityConfigCallback)</span> </span>&#123;</span><br><span class="line">    attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">    mFragments.attachHost(<span class="keyword">null</span> <span class="comment">/*parent*/</span>);</span><br><span class="line"></span><br><span class="line">    mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window, activityConfigCallback);</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mWindow.setContainer(mParent.getWindow());</span><br><span class="line">    &#125;</span><br><span class="line">    mWindowManager = mWindow.getWindowManager();</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Activity的attach函数内部初始化Activity的成员变量，创建了PhoneWindow对象并为PhoneWindow和Activity创建了WindowManagerImpl对象,getWindow函数返回了Activity类中的mWindow对象，在Activity.attach函数中创建了PhoneWindow对象并保存为mWindow。关于attach方法的细节留到后面再谈，现在继续看mInstrumentation.callActivityOnCreate方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnCreate</span><span class="params">(Activity activity, Bundle icicle)</span> </span>&#123;</span><br><span class="line">        prePerformCreate(activity);</span><br><span class="line">        activity.performCreate(icicle);</span><br><span class="line">        postPerformCreate(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Perform calling of an activity's &#123;<span class="doctag">@link</span> Activity#onCreate&#125;</span></span><br><span class="line"><span class="comment">     * method.  The default implementation simply calls through to that method.</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@param</span> activity The activity being created.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> icicle The previously frozen state (or null) to pass through to</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> persistentState The previously persisted state (or null)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnCreate</span><span class="params">(Activity activity, Bundle icicle,</span></span></span><br><span class="line"><span class="function"><span class="params">            PersistableBundle persistentState)</span> </span>&#123;</span><br><span class="line">        prePerformCreate(activity);</span><br><span class="line">        activity.performCreate(icicle, persistentState);</span><br><span class="line">        postPerformCreate(activity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最终activity的创建来到了它的performCreate方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performCreate</span><span class="params">(Bundle icicle)</span> </span>&#123;</span><br><span class="line">       performCreate(icicle, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performCreate</span><span class="params">(Bundle icicle, PersistableBundle persistentState)</span> </span>&#123;</span><br><span class="line">       mCanEnterPictureInPicture = <span class="keyword">true</span>;</span><br><span class="line">       restoreHasCurrentPermissionRequest(icicle);</span><br><span class="line">       <span class="keyword">if</span> (persistentState != <span class="keyword">null</span>) &#123;</span><br><span class="line">           onCreate(icicle, persistentState);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           onCreate(icicle);</span><br><span class="line">       &#125;</span><br><span class="line">       writeEventLog(LOG_AM_ON_CREATE_CALLED, <span class="string">"performCreate"</span>);</span><br><span class="line">       mActivityTransitionState.readState(icicle);</span><br><span class="line"></span><br><span class="line">       mVisibleFromClient = !mWindow.getWindowStyle().getBoolean(</span><br><span class="line">               com.android.internal.R.styleable.Window_windowNoDisplay, <span class="keyword">false</span>);</span><br><span class="line">       mFragments.dispatchActivityCreated();</span><br><span class="line">       mActivityTransitionState.setEnterActivityOptions(<span class="keyword">this</span>, getActivityOptions());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>最终这里调用了那个熟悉的onCreate方法，也就意味着整个启动流程已经走完了，不得不说整个流程还是比较复杂的，但在用户使用的时候就是点击一下然后app就启动到眼前一瞬间的事。拉完整个流程对笔者的帮助真的很大，不仅收获了很多源码阅读的经验，还能了解系统的工作原理，但只浏览了一遍大体流程，许多地方还未真正理解和体会到它的意义与设计的巧妙。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">zhf</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/08/02/浅谈App启动流程/">http://yoursite.com/2019/08/02/浅谈App启动流程/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android    </a><a class="post-meta__tags" href="/tags/源码分析/">源码分析    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-buttom"><i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2019/08/08/浅谈Window视图绑定与工作原理/"><img class="prev_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>浅谈Window视图绑定与工作原理</span></div></a></div><div class="next-post pull-right"><a href="/2019/07/30/hello-world/"><img class="next_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>Hello World</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span>Recommend</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/07/30/浅谈Handler内部原理/" title="浅谈Handler内部原理"><img class="relatedPosts_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_title">浅谈Handler内部原理</div></a></div><div class="relatedPosts_item"><a href="/2019/08/08/浅谈Window视图绑定与工作原理/" title="浅谈Window视图绑定与工作原理"><img class="relatedPosts_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_title">浅谈Window视图绑定与工作原理</div></a></div><div class="relatedPosts_item"><a href="/2019/08/18/Android View对象创建流程分析/" title="Android XML布局到View对象创建流程分析"><img class="relatedPosts_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_title">Android XML布局到View对象创建流程分析</div></a></div></div><div class="clear_both"></div></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2019 By zhf</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><i class="fa fa-book" id="readmode" title="Read Mode"> </i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion">简</a><i class="fa fa-moon-o nightshift" id="nightshift" title="Dark Mode"></i></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zindex="-1" data-click="false"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/js/piao.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script></body></html>