<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>demoless.github.io</title><meta name="description" content><meta name="keywords" content><meta name="author" content="zhf"><meta name="copyright" content="zhf"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://yoursite.com/2020/10/27/RecyclerView渲染流程/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content><meta name="twitter:description" content><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png"><meta property="og:type" content="article"><meta property="og:title" content><meta property="og:url" content="http://yoursite.com/2020/10/27/RecyclerView渲染流程/"><meta property="og:site_name" content="demoless.github.io"><meta property="og:description" content><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title href="http://yoursite.com/2020/10/27/FragmentDialog详解/"><link rel="next" title="Gradle学习笔记" href="http://yoursite.com/2020/04/09/Gradle学习笔记/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Bookmark',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days'

  
}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#RecyclerView渲染流程"><span class="toc-number">1.</span> <span class="toc-text">RecyclerView渲染流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#onMeasure实现原理"><span class="toc-number">1.1.</span> <span class="toc-text">onMeasure实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#defaultOnMeasure实现"><span class="toc-number">1.1.1.</span> <span class="toc-text">defaultOnMeasure实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LayoutManager自动测量"><span class="toc-number">1.1.2.</span> <span class="toc-text">LayoutManager自动测量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锚点的选择"><span class="toc-number">1.2.</span> <span class="toc-text">锚点的选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#布局的填充"><span class="toc-number">1.3.</span> <span class="toc-text">布局的填充</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/post.png)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">demoless.github.io</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"><div class="mobile_author-info__description"></div></div><hr><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title"><div class="posttitle">No title</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2020-10-27<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> Updated 2020-10-28</time><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">4.1k</span><span class="post-meta__separator">|</span><span>Reading time: 15 min</span><span class="post-meta__separator">|</span><span>Post View: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="RecyclerView渲染流程"><a href="#RecyclerView渲染流程" class="headerlink" title="RecyclerView渲染流程"></a>RecyclerView渲染流程</h1><p><img src="https://cdn.jsdelivr.net/gh/demoless/imgs/noteimage-20201027104137833.png" alt="image-20201027104137833"></p>
<p>RecyclerView继承自ViewGroup，其展示流程入口就还得是onMeasure、onLayout方法，下面将从这两个方法作为入口，探究RecyclerView展示的原理。</p>
<p><img src="https://cdn.jsdelivr.net/gh/demoless/imgs/noteimage-20201027104001882.png" alt="recyclerView-onMeasure"></p>
<p><img src="https://cdn.jsdelivr.net/gh/demoless/imgs/noteimage-20201027104712356.png" alt="image-20201027104712356"></p>
<h2 id="onMeasure实现原理"><a href="#onMeasure实现原理" class="headerlink" title="onMeasure实现原理"></a>onMeasure实现原理</h2><p>onMeasure方法的代码很长，这里放上一段精简过的伪代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthSpec, <span class="keyword">int</span> heightSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mLayout == <span class="keyword">null</span>) &#123;</span><br><span class="line">            defaultOnMeasure(widthSpec, heightSpec);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mLayout.isAutoMeasureEnabled()) &#123;</span><br><span class="line">			···</span><br><span class="line">            <span class="comment">//调用LayoutManager的onMeasure方法来进行测量工作</span></span><br><span class="line">            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">			···</span><br><span class="line">            <span class="comment">//如果width和height都已经是精确值，那么就不用再根据内容进行测量，后面步骤不再处理</span></span><br><span class="line">            <span class="keyword">if</span> (skipMeasure || mAdapter == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class="line">                <span class="comment">//布局的第一部 主要进行一些初始化的工作</span></span><br><span class="line">                dispatchLayoutStep1();</span><br><span class="line">            &#125;</span><br><span class="line">          	...</span><br><span class="line">            <span class="comment">//开启了自动测量，需要先确认子View的大小与布局</span></span><br><span class="line">            dispatchLayoutStep2();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//再根据子View的情况决定自身的大小</span></span><br><span class="line">            mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mLayout.shouldMeasureTwice()) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">//如果有父子尺寸属性互相依赖的情况，要改变参数重新进行一次</span></span><br><span class="line">                dispatchLayoutStep2();</span><br><span class="line">                mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mHasFixedSize) &#123;</span><br><span class="line">                mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// custom onMeasure</span></span><br><span class="line">            <span class="keyword">if</span> (mAdapterUpdateDuringMeasure) &#123;</span><br><span class="line">                ···</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mState.mRunPredictiveAnimations) &#123;</span><br><span class="line">                setMeasuredDimension(getMeasuredWidth(), getMeasuredHeight());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ···</span><br><span class="line">            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">            ···</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里的mLayout对象是LayoutManager，measure过程主要分为了这样几种情况：</p>
<p>1、LayoutManager为空，使用默认测量方案通过defaultOnMeasure方法完成</p>
<p>2、有LayoutManager，开启了自动测量。</p>
<p>这种情况是最复杂的，需要根据子View的布局来调整自身的大小。需要知道子View的大小和布局。所以RecyclerView将布局的过程提前到这里来进行了</p>
<p>3、有LayoutManager，而且关闭了自动测量功能。</p>
<p>关闭测量的情况下不需要考虑子View的大小和布局。直接按照正常的流程来进行测量即可。如果直接已经设置了固定的宽高，那么直接使用固定值即可。如果没有设置固定宽高，那么就按照正常的控件一样，根据父级的要求与自身的属性进行测量</p>
<h3 id="defaultOnMeasure实现"><a href="#defaultOnMeasure实现" class="headerlink" title="defaultOnMeasure实现"></a>defaultOnMeasure实现</h3><p><img src="https://cdn.jsdelivr.net/gh/demoless/imgs/noteimage-20201027111253599.png" alt="image-20201027111253599"></p>
<p>chooseSize方法中根据measureMode来确认RecyclerView的宽高，然后调用setMeasuredDimension方法设置测量的宽高。这里并没有对子View进行measure，也就是说在LayoutManager为空的情况下，测量的宽高是不含item的，显示出的效果就是空白，这也能很好的解释当你忘记调用setLayoutManager方法的时候，并不能符合预期的展示而是一片空白。</p>
<h3 id="LayoutManager自动测量"><a href="#LayoutManager自动测量" class="headerlink" title="LayoutManager自动测量"></a>LayoutManager自动测量</h3><p>自动测量的原理如下:</p>
<p>当RecyclerView的宽高都为EXACTLY时，可以直接设置对应的宽高，然后返回，结束测量。如果宽高的测量规则不是EXACTLY的,则会在onMeasure()中开始布局的处理，这里首先要介绍一个很重要的类：RecyclerView.State ，这个类封装了当前RecyclerView的有用信息。State的一个变量mLayoutStep表示了RecyclerView当前的布局状态，包括STEP_START、STEP_LAYOUT 、 STEP_ANIMATIONS三个，而RecyclerView的布局过程也分为三步，其中，STEP_START表示即将开始布局，需要调用dispatchLayoutStep1来执行第一步布局，接下来，布局状态变为STEP_LAYOUT，表示接下来需要调用dispatchLayoutStep2里进行第二步布局，同理，第二步布局后状态变为STEP_ANIMATIONS，需要执行第三步布局dispatchLayoutStep3。</p>
<p>这三个步骤的工作也各不相同，step1负责记录状态，step2负责布局，step3则与step1进行比较，根据变化来触发动画.在开启自动测量的情况下如果没有设置固定宽高，那么会执行setp1和step2。在step2执行完后就可以调用 <strong>setMeasuredDimensionFromChildren</strong> 方法，根据子类的测量布局结果来设置自身的大小</p>
<p>先不进行分析step1，step2和step3的具体功能。直接把 <strong>onLayout</strong> 的代码也贴出来，看一下这3步是如何保证都能够执行的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//RecyclerView.java</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        dispatchLayout();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispatchLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mAdapter == <span class="keyword">null</span>) &#123;<span class="comment">//没有设置adapter，返回</span></span><br><span class="line">            Log.e(TAG, <span class="string">"No adapter attached; skipping layout"</span>);</span><br><span class="line">            <span class="comment">// leave the state in START</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mLayout == <span class="keyword">null</span>) &#123;<span class="comment">//没有设置LayoutManager，返回</span></span><br><span class="line">            Log.e(TAG, <span class="string">"No layout manager attached; skipping layout"</span>);</span><br><span class="line">            <span class="comment">// leave the state in START</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mState.mIsMeasuring = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//在onMeasure阶段，如果宽高是固定的，那么mLayoutStep == State.STEP_START 而且dispatchLayoutStep1和dispatchLayoutStep2不会调用</span></span><br><span class="line">        <span class="comment">//所以这里就会调用一下</span></span><br><span class="line">        <span class="keyword">if</span> (mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class="line">            dispatchLayoutStep1();</span><br><span class="line">            mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">            dispatchLayoutStep2();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth()|| mLayout.getHeight() != getHeight()) &#123;</span><br><span class="line">            <span class="comment">//在onMeasure阶段，如果执行了dispatchLayoutStep1，但是没有执行dispatchLayoutStep2,就会执行dispatchLayoutStep2</span></span><br><span class="line">            mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">            dispatchLayoutStep2();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最终调用dispatchLayoutStep3</span></span><br><span class="line">        dispatchLayoutStep3();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，其实在 <strong>onLayout</strong> 阶段会根据 <strong>onMeasure</strong> 阶段3个步骤执行到了哪个，然后会在 <strong>onLayout</strong> 中把剩下的步骤执行.在这3个步骤中，step2就是执行了子View的测量布局的一步，也是最重要的一环，所以我们将关注的重点放在这个函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//RecyclerView.java</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//禁止布局请求</span></span><br><span class="line">        eatRequestLayout();</span><br><span class="line">        ...</span><br><span class="line">        mState.mInPreLayout = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//调用LayoutManager的layoutChildren方法来布局</span></span><br><span class="line">        mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class="line">		...</span><br><span class="line">        resumeRequestLayout(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里调用LayoutManager的 <strong>onLayoutChildren</strong> 方法，将对于子View的测量和布局工作交给了LayoutManager。而且我们在自定义LayoutManager的时候也必须要重写这个方法来描述我们的布局错略。这里我们分析最经常使用的 <strong>LinearLayoutManager</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LinearLayoutManager.java</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLayoutChildren</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// layout algorithm:</span></span><br><span class="line">        <span class="comment">// 1) by checking children and other variables, find an anchor coordinate and an anchor</span></span><br><span class="line">        <span class="comment">//  item position.</span></span><br><span class="line">        <span class="comment">// 2) fill towards start, stacking from bottom</span></span><br><span class="line">        <span class="comment">// 3) fill towards end, stacking from top</span></span><br><span class="line">        <span class="comment">// 4) scroll to fulfill requirements like stack from bottom.</span></span><br><span class="line">        <span class="comment">// create layout state</span></span><br></pre></td></tr></table></figure>

<p><strong>LinearLayoutManager</strong> 中的布局策略主要是以下几个方面：</p>
<ol>
<li>通过子控件和其他的变量信息。找到一个锚点和锚点项的位置。</li>
<li>从锚点的位置开始，往上，填充布局子View，直到填满区域</li>
<li>从锚点的位置开始，往下，填充布局子View，直到填满区域</li>
<li>滚动以满足需求，如堆栈从底部</li>
</ol>
<p>这里有个比较关键的词，就是 <strong>锚点(AnchorInfo)</strong> ，其实 LinearLayoutManager的布局并不是从上往下一个个进行的。而是很可能从整个布局的中间某个点开始的，然后朝一个方向一个个填充，填满可见区域后，朝另一个方向进行填充。至于先朝哪个方向填充，是根据具体的变量来确定的</p>
<h2 id="锚点的选择"><a href="#锚点的选择" class="headerlink" title="锚点的选择"></a>锚点的选择</h2><p><strong>AnchorInfo</strong> 类需要能够有效的描述一个具体的位置信息，我们首先类内部的几个重要的成员变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LinearLayoutManager.java</span></span><br><span class="line">	<span class="comment">//简单的数据类来保存锚点信息</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AnchorInfo</span> </span>&#123;</span><br><span class="line">        <span class="comment">//锚点参考View在整个数据中的position信息，即它是第几个View</span></span><br><span class="line">        <span class="keyword">int</span> mPosition;</span><br><span class="line">        <span class="comment">//锚点的具体坐标信息，填充子View的起始坐标。当positon=0的时候，如果只有一半View可见，那么这个数据可能为负数</span></span><br><span class="line">        <span class="keyword">int</span> mCoordinate;</span><br><span class="line">        <span class="comment">//是否从底部开始布局</span></span><br><span class="line">        <span class="keyword">boolean</span> mLayoutFromEnd;</span><br><span class="line">        <span class="comment">//是否有效</span></span><br><span class="line">        <span class="keyword">boolean</span> mValid;</span><br></pre></td></tr></table></figure>

<p>通过 <strong>AnchorInfo</strong> 就可以准确的定位当前的位置信息了,现在再看看onLayoutChildren中具体的处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LinearLayoutManager.java</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLayoutChildren</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//确认LayoutState存在</span></span><br><span class="line">        ensureLayoutState();</span><br><span class="line">        <span class="comment">//禁止回收</span></span><br><span class="line">        mLayoutState.mRecycle = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//计算是否需要颠倒绘制。是从底部到顶部绘制，还是从顶部到底部绘制</span></span><br><span class="line">        resolveShouldLayoutReverse();</span><br><span class="line">        <span class="comment">//如果当前锚点信息非法，滑动到的位置不可用或者有需要恢复的存储的SaveState</span></span><br><span class="line">        <span class="keyword">if</span> (!mAnchorInfo.mValid || mPendingScrollPosition != NO_POSITION || mPendingSavedState != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//重置锚点信息</span></span><br><span class="line">            mAnchorInfo.reset();</span><br><span class="line">            <span class="comment">//是否从end开始进行布局。因为mShouldReverseLayout和mStackFromEnd默认都是false，那么我们这里可以考虑按照默认的情况来进行分析，也就是mLayoutFromEnd也是false</span></span><br><span class="line">            mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd;</span><br><span class="line">            <span class="comment">//计算锚点的位置和坐标</span></span><br><span class="line">            updateAnchorInfoForLayout(recycler, state, mAnchorInfo);</span><br><span class="line">            <span class="comment">//设置锚点有效</span></span><br><span class="line">            mAnchorInfo.mValid = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在需要确定锚点的时候，会先将锚点进行初始化，然后通过 <strong>updateAnchorInfoForLayout</strong> 方法来确定锚点的信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LinearLayoutManager.java</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateAnchorInfoForLayout</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state, AnchorInfo anchorInfo)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从挂起的数据更新锚点信息  这个方法一般不会调用到</span></span><br><span class="line">        <span class="keyword">if</span> (updateAnchorFromPendingData(state, anchorInfo)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重点方法 从子View来确定锚点信息（这里会尝试从有焦点的子View或者列表第一个位置的View或者最后一个位置的View来确定）</span></span><br><span class="line">        <span class="keyword">if</span> (updateAnchorFromChildren(recycler, state, anchorInfo)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进入这里说明现在都没有确定锚点（比如设置Data后还没有绘制View的情况下），就直接设置RecyclerView的顶部或者底部位置为锚点(按照默认情况，这里的mPosition=0)。</span></span><br><span class="line">        anchorInfo.assignCoordinateFromPadding();</span><br><span class="line">        anchorInfo.mPosition = mStackFromEnd ? state.getItemCount() - <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>锚点的确定方案主要有3个：</p>
<ol>
<li>从挂起的数据获取锚点信息。一般不会执行。</li>
<li>从子View来确定锚点信息。比如说notifyDataSetChanged方法的时候，屏幕上原来是有View的，那么就会通过这种方式获取</li>
<li>如果上面两种方法都无法确定，其实就是没有子View让我们作为参考。比如说第一次加载数据的时候，RecyclerView一片空白则直接使用0位置的View作为锚点参考position。</li>
</ol>
<p>那么当有子View的时候，我们通过 <strong>updateAnchorFromChildren</strong> 方法来确定锚点位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LinearLayoutManager.java</span></span><br><span class="line">	<span class="comment">//从现有子View中确定锚定。大多数情况下，是起始或者末尾的有效子View(一般是未移除，展示在我们面前的View)。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">updateAnchorFromChildren</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state, AnchorInfo anchorInfo)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//没有数据，直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (getChildCount() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> View focused = getFocusedChild();</span><br><span class="line">        <span class="comment">//优先选取获得焦点的子View作为锚点</span></span><br><span class="line">        <span class="keyword">if</span> (focused != <span class="keyword">null</span> &amp;&amp; anchorInfo.isViewValidAsAnchor(focused, state)) &#123;</span><br><span class="line">            <span class="comment">//保持获取焦点的子view的位置信息</span></span><br><span class="line">            anchorInfo.assignFromViewAndKeepVisibleRect(focused);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mLastStackFromEnd != mStackFromEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据锚点的设置信息，从底部或者顶部获取子View信息</span></span><br><span class="line">        View referenceChild = anchorInfo.mLayoutFromEnd ? findReferenceChildClosestToEnd(recycler, state) : findReferenceChildClosestToStart(recycler, state);</span><br><span class="line">        <span class="keyword">if</span> (referenceChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            anchorInfo.assignFromView(referenceChild);</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过子View确定锚点坐标也是进行了3种情况的处理</p>
<ol>
<li>没有数据，直接返回获取失败</li>
<li>如果某个子View持有焦点，那么直接把持有焦点的子View作为锚点参考点</li>
<li>没有子View持有焦点，一般会选择最上（或者最下面）的子View作为锚点参考点</li>
</ol>
<p>一般情况下，都会使用第三种方案来确定锚点，所以我们这里也主要关注一下这里的方法。按照我们默认的变量信息，这里会通过 <strong>findReferenceChildClosestToStart</strong> 方法获取可见区域中的第一个子View作为锚点的参考View。然后调用 <strong>assignFromView</strong> 方法来确定锚点的几个属性值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LinearLayoutManager.java</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assignFromView</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (mLayoutFromEnd) &#123;</span><br><span class="line">                <span class="comment">//如果是从底部布局，那么获取child的底部的位置设置为锚点</span></span><br><span class="line">                mCoordinate = mOrientationHelper.getDecoratedEnd(child) + mOrientationHelper.getTotalSpaceChange();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果是从顶部开始布局，那么获取child的顶部的位置设置为锚点坐标(这里要考虑ItemDecorator的情况)</span></span><br><span class="line">                mCoordinate = mOrientationHelper.getDecoratedStart(child);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//mPosition赋值为参考View的position</span></span><br><span class="line">            mPosition = getPosition(child);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>mPostion这个变量很好理解，就是子View的位置值，那么 <strong>mCoordinate</strong> 是个什么,看<strong>getDecoratedStart</strong> 是怎么处理的就知道了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LinearLayoutManager.java</span></span><br><span class="line">        <span class="comment">//创建mOrientationHelper。我们按照垂直布局来进行分析</span></span><br><span class="line">        <span class="keyword">if</span> (mOrientationHelper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mOrientationHelper = OrientationHelper.createOrientationHelper(<span class="keyword">this</span>, mOrientation);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//OrientationHelper.java</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OrientationHelper <span class="title">createVerticalHelper</span><span class="params">(RecyclerView.LayoutManager layoutManager)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OrientationHelper(layoutManager) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDecoratedStart</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> RecyclerView.LayoutParams params =  (RecyclerView.LayoutParams)view.getLayoutParams();</span><br><span class="line">                <span class="keyword">return</span> mLayoutManager.getDecoratedTop(view) - params.topMargin;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="布局的填充"><a href="#布局的填充" class="headerlink" title="布局的填充"></a>布局的填充</h2><p>回到主线 <strong>onLayoutChildren</strong> 函数。当我们的锚点信息确认以后，剩下的就是从这个位置开始进行布局的填充</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mAnchorInfo.mLayoutFromEnd) &#123;<span class="comment">//从end开始布局</span></span><br><span class="line">            <span class="comment">//倒着绘制的话，先从锚点往上，绘制完再从锚点往下</span></span><br><span class="line">            <span class="comment">//设置绘制方向信息为从锚点往上</span></span><br><span class="line">            updateLayoutStateToFillStart(mAnchorInfo);</span><br><span class="line">            mLayoutState.mExtra = extraForStart;</span><br><span class="line">            fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">            startOffset = mLayoutState.mOffset;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> firstElement = mLayoutState.mCurrentPosition;</span><br><span class="line">            <span class="keyword">if</span> (mLayoutState.mAvailable &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                extraForEnd += mLayoutState.mAvailable;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//设置绘制方向信息为从锚点往下</span></span><br><span class="line">            updateLayoutStateToFillEnd(mAnchorInfo);</span><br><span class="line">            mLayoutState.mExtra = extraForEnd;</span><br><span class="line">            mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;</span><br><span class="line">            fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">            endOffset = mLayoutState.mOffset;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mLayoutState.mAvailable &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                extraForStart = mLayoutState.mAvailable;</span><br><span class="line">                updateLayoutStateToFillStart(firstElement, startOffset);</span><br><span class="line">                mLayoutState.mExtra = extraForStart;</span><br><span class="line">                fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">                startOffset = mLayoutState.mOffset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//从起始位置开始布局</span></span><br><span class="line">            <span class="comment">// 更新layoutState，设置布局方向朝下</span></span><br><span class="line">            updateLayoutStateToFillEnd(mAnchorInfo);</span><br><span class="line">            mLayoutState.mExtra = extraForEnd;</span><br><span class="line">            <span class="comment">//开始填充布局</span></span><br><span class="line">            fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//结束偏移</span></span><br><span class="line">            endOffset = mLayoutState.mOffset;</span><br><span class="line">            <span class="comment">//绘制后的最后一个view的position</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> lastElement = mLayoutState.mCurrentPosition;</span><br><span class="line">            <span class="keyword">if</span> (mLayoutState.mAvailable &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                extraForStart += mLayoutState.mAvailable;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新layoutState，设置布局方向朝上</span></span><br><span class="line">            updateLayoutStateToFillStart(mAnchorInfo);</span><br><span class="line">            mLayoutState.mExtra = extraForStart;</span><br><span class="line">            mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;</span><br><span class="line">            <span class="comment">//再次填充布局</span></span><br><span class="line">            fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//起始位置的偏移</span></span><br><span class="line">            startOffset = mLayoutState.mOffset;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mLayoutState.mAvailable &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                extraForEnd = mLayoutState.mAvailable;</span><br><span class="line">                updateLayoutStateToFillEnd(lastElement, endOffset);</span><br><span class="line">                mLayoutState.mExtra = extraForEnd;</span><br><span class="line">                fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">                endOffset = mLayoutState.mOffset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，根据不同的绘制方向，这里面做了不同的处理，只是填充的方向相反而已，具体的步骤是相似的。都是从锚点开始往一个方向进行View的填充，填充满以后再朝另一个方向填充。填充子View使用的是 <strong>fill()</strong> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在LinearLayoutManager中，进行界面重绘和进行滑动两种情况下，往屏幕上填充子View的工作都是调用fill()进行</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fill</span><span class="params">(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.State state, <span class="keyword">boolean</span> stopOnFocusable)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//可用区域的像素数</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> start = layoutState.mAvailable;</span><br><span class="line">        <span class="keyword">if</span> (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) &#123;</span><br><span class="line">            <span class="keyword">if</span> (layoutState.mAvailable &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                layoutState.mScrollingOffset += layoutState.mAvailable;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将滑出屏幕的View回收掉</span></span><br><span class="line">            recycleByLayoutState(recycler, layoutState);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//剩余绘制空间=可用区域+扩展空间。</span></span><br><span class="line">        <span class="keyword">int</span> remainingSpace = layoutState.mAvailable + layoutState.mExtra;</span><br><span class="line">        LayoutChunkResult layoutChunkResult = mLayoutChunkResult;</span><br><span class="line">        <span class="comment">//循环布局直到没有剩余空间了或者没有剩余数据了</span></span><br><span class="line">        <span class="keyword">while</span> ((layoutState.mInfinite || remainingSpace &gt; <span class="number">0</span>) &amp;&amp; layoutState.hasMore(state)) &#123;</span><br><span class="line">            <span class="comment">//初始化layoutChunkResult</span></span><br><span class="line">            layoutChunkResult.resetInternal();</span><br><span class="line">            <span class="comment">//重点方法  添加一个child，然后将绘制的相关信息保存到layoutChunkResult</span></span><br><span class="line">            layoutChunk(recycler, state, layoutState, layoutChunkResult);</span><br><span class="line">            <span class="keyword">if</span> (layoutChunkResult.mFinished) &#123;<span class="comment">//如果布局结束了(没有view了)，退出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据所添加的child消费的高度更新layoutState的偏移量。mLayoutDirection为+1或者-1，通过乘法来处理是从底部往上布局，还是从上往底部开始布局</span></span><br><span class="line">            layoutState.mOffset += layoutChunkResult.mConsumed * layoutState.mLayoutDirection;</span><br><span class="line">            <span class="keyword">if</span> (!layoutChunkResult.mIgnoreConsumed || mLayoutState.mScrapList != <span class="keyword">null</span> || !state.isPreLayout()) &#123;</span><br><span class="line">                layoutState.mAvailable -= layoutChunkResult.mConsumed;</span><br><span class="line">                <span class="comment">//消费剩余可用空间</span></span><br><span class="line">                remainingSpace -= layoutChunkResult.mConsumed;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回本次布局所填充的区域</span></span><br><span class="line">        <span class="keyword">return</span> start - layoutState.mAvailable;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在 <strong>fill</strong> 方法中，会判断当前的是否还有剩余区域可以进行子View的填充。如果没有剩余区域或者没有子View，那么就返回。否则就通过 <strong>layoutChunk</strong> 来进行填充工作，填充完毕以后更新当前的可用区域，然后依次遍历循环，直到不满足条件为止</p>
<p>循环中的填充是通过 <strong>layoutChunk</strong> 来实现的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutChunk</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state,LayoutState layoutState, LayoutChunkResult result)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//通过缓存获取当前position所需要展示的ViewHolder的View</span></span><br><span class="line">       View view = layoutState.next(recycler);</span><br><span class="line">       <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//如果我们将视图放置在废弃视图中，这可能会返回null，这意味着没有更多的项需要布局。</span></span><br><span class="line">           result.mFinished = <span class="keyword">true</span>;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       LayoutParams params = (LayoutParams) view.getLayoutParams();</span><br><span class="line">       <span class="keyword">if</span> (layoutState.mScrapList == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//根据方向调用addView方法添加子View</span></span><br><span class="line">           <span class="keyword">if</span> (mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) &#123;</span><br><span class="line">               addView(view);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               addView(view, <span class="number">0</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) &#123;</span><br><span class="line">               <span class="comment">//这里是即将消失的View，但是需要设置对应的移除动画</span></span><br><span class="line">               addDisappearingView(view);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               addDisappearingView(view, <span class="number">0</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//调用measure测量view。这里会考虑到父类的padding</span></span><br><span class="line">       measureChildWithMargins(view, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">       <span class="comment">//将本次子View消费的区域设置为子view的高(或者宽)</span></span><br><span class="line">       result.mConsumed = mOrientationHelper.getDecoratedMeasurement(view);</span><br><span class="line">       <span class="comment">//找到view的四个边角位置</span></span><br><span class="line">       <span class="keyword">int</span> left, top, right, bottom;</span><br><span class="line">       ...</span><br><span class="line">       <span class="comment">//调用child.layout方法进行布局(这里会考虑到view的ItemDecorator等信息)</span></span><br><span class="line">       layoutDecoratedWithMargins(view, left, top, right, bottom);</span><br><span class="line">       <span class="comment">//如果视图未被删除或更改，则使用可用空间</span></span><br><span class="line">       <span class="keyword">if</span> (params.isItemRemoved() || params.isItemChanged()) &#123;</span><br><span class="line">           result.mIgnoreConsumed = <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       result.mFocusable = view.isFocusable();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里主要做了5个处理:</p>
<ol>
<li>通过 <strong>layoutState</strong> 获取要展示的View</li>
<li>通过 <strong>addView</strong> 方法将子View添加到布局中</li>
<li>调用 <strong>measureChildWithMargins</strong> 方法测量子View</li>
<li>调用 <strong>layoutDecoratedWithMargins</strong> 方法布局子View</li>
<li>根据处理的结果，填充LayoutChunkResult的相关信息，以便返回之后，能够进行数据的计算</li>
</ol>
<p>如果只是考虑第一次数据加载，那么到目前为止，我们的整个页面通过两次 <strong>fill</strong> 就能够将整个屏幕填充完毕了</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">zhf</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/10/27/RecyclerView渲染流程/">http://yoursite.com/2020/10/27/RecyclerView渲染流程/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-buttom"><i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2020/10/27/FragmentDialog详解/"><img class="prev_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span></span></div></a></div><div class="next-post pull-right"><a href="/2020/04/09/Gradle学习笔记/"><img class="next_cover lozad" data-src="https://cdn.jsdelivr.net/gh/demoless/imgs/note下载.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>Gradle学习笔记</span></div></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2020 By zhf</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><i class="fa fa-book" id="readmode" title="Read Mode"> </i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion">简</a><i class="fa fa-moon-o nightshift" id="nightshift" title="Dark Mode"></i></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zindex="-1" data-click="false"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/js/piao.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script></body></html>